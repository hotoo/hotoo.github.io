"use strict";(self.webpackChunkhotoo_co=self.webpackChunkhotoo_co||[]).push([["1326"],{759:function(e,n,t){t.r(n),t.d(n,{default:()=>d});var s=t(4132),o=t(453),a=t(3030);function r(e){let n=Object.assign({h1:"h1",a:"a",p:"p",code:"code",pre:"pre",strong:"strong",blockquote:"blockquote",em:"em",h2:"h2",footer:"footer",div:"div",cite:"cite"},(0,o.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"测试代码和可测试代码",children:["测试代码和可测试代码",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#测试代码和可测试代码",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["项目中有一个要将指定时间和当前时间比较，计算相对时间的逻辑（比如显示 ",(0,s.jsx)(n.code,{children:"3 分钟前"}),"），\n由于当前时间和执行测试用例的时机有关，每次执行用例都会不同，如何让这个代码可测试呢？\n有些人可能想到 Mock 当前时间，测试的时候让当前时间凝固，于是有了如下代码："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 实际业务代码中：\n// 虽然本来只需要 moment() 就可以了，但是为了方便测试，传入了一个可 Mock 的 Date.now\nconst now = moment(Date.now());\n\n// 测试用例中，Mock Date.now 方法：\nmm(Date, 'now', () => 1464969293129);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["这个业务代码是 ",(0,s.jsx)(n.strong,{children:"可测试"})," 的代码吗？我认为不是。"]}),"\n",(0,s.jsxs)(n.p,{children:["这个业务代码为了测试，使用了一个不必要的方法，而且让测试代码和业务逻辑相互依赖，\n一旦业务代码重构，测试代码将不可测试。这个代码是为测试写的，称之为 ",(0,s.jsx)(n.strong,{children:"测试"})," 代码\n而不是 ",(0,s.jsx)(n.strong,{children:"可测试"})," 代码更合适点。"]}),"\n",(0,s.jsx)(n.p,{children:"再举一个例子，还是时间相关的动态数据输入问题："}),"\n",(0,s.jsx)(n.p,{children:"项目中有一个今日收益更新的提醒消息，只有是今天的更新才显示，所以第一直觉应该是造一个\n收益更新时间是今天的测试数据，而不是造一个固定的数据（可能固定测试数据比较偷懒方便），\n然后篡改业务逻辑中当前时间的计算。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 业务代码正常该怎么写怎么写，不用管测试怎么活。\nconst today = moment().format('YYYYMMDD');\nif (data.updateDate === today) {\n  // show message.\n}\n\n// 活的测试数据\ndata.updateDate = moment().format('YYYYMMDD');\n"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["测试代码应该只关注正常的数据输入和输出 ",(0,s.jsx)(n.em,{children:"（即使输入、输出是难以预测的）"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"而不应该关注业务实现逻辑，试图篡改业务代码，让测试可以进行。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"更好一点的可测试代码，可以将当前时间传入以便让输入、输出可以预测："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 业务抽象\n// 计算两个时间差，格式化为 `3 分钟前` 等相对时间。\n// @param {Date|Number} date1 较早的时间或时间戳。\n// @param {Date|Number} date2 较晚的时间或时间戳，默认当前时间。\n// @return {String} 相对时间差\nfunction dateDiff(date1, date2 = Date.now()) {\n  // ...\n}\n\n// 业务调用\ndateDiff(data.datetime);\n\n// 测试代码\nassert(dateDiff(new Date(2016,0,1,0,0,0,0), new Date(2016,0,1,0,0,0,10)) === '刚刚');\nassert(dateDiff(new Date(2016,0,1,0,0,0,0), new Date(2016,0,1,0,3,0,0)) === '3 分钟前');\nassert(dateDiff(new Date(2016,0,1,0,0,0,0), new Date(2016,0,1,1,0,0,0)) === '1 小时前');\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"2017-02-09-更新",children:["2017-02-09 更新",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2017-02-09-更新",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"群里又有了类似的一个案例，开发想写测试用例来测 location.href 的赋值是否正确，\n用以测试页面跳转逻辑是否正确。于是想通过重载 location 对象来监听给 location.href\n赋值时，所赋值是否符合期望。"}),"\n",(0,s.jsxs)(n.p,{children:["还辛苦找到 ",(0,s.jsx)(n.a,{href:"https://zhuanlan.zhihu.com/p/24342684",target:"_blank",rel:"noopener noreferrer",children:"Chrome 出了个小 bug：论如何在 Chrome 下劫持原生只读对象"}),"\n这么牛逼变态到令人折服的方法。但是，这是正确的方法吗？我认为不是。"]}),"\n",(0,s.jsxs)(n.p,{children:["location 的案例中，我觉得应该是测试赋值给 location.href 的 ",(0,s.jsx)(n.strong,{children:"值"}),"本身是否正确，\n而不是测试企图篡改 location 来监听 href 属性是否正确。即："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 业务代码\nfunction getUrl(){}\nlocation.href = getUrl(...args);\n"})}),"\n",(0,s.jsx)(n.p,{children:"单元测试用例只需要测试 getUrl 在各种边界输入条件下，输出是否符合期望就可以了。"}),"\n",(0,s.jsxs)("footer",{class:"blog-post-footer",children:[(0,s.jsx)("div",{class:"blog-post-footer-meta meta-left",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Tags:"})," ",(0,s.jsx)("a",{href:"/blog/tags/Code",children:(0,s.jsx)("cite",{class:"tags",children:"Code"})})]})}),(0,s.jsx)("div",{class:"blog-post-footer-meta meta-right",children:(0,s.jsxs)(n.p,{children:["Published on ",(0,s.jsx)("cite",{class:"date",children:"2016-06-04"})]})})]}),"\n",(0,s.jsx)(a.DiscussionEmbed,{shortname:"hotoo",config:{url:"https://hotoo.co/blog/post/test-code-and-testable-code.html",identifier:["github-gitlab-or-bitbucket","git-branch","vim-tutor","eventlistenerlist","gtalk-group-for-vim","dropbox-died-in-china","vim-chinese-doc"].includes("test-code-and-testable-code")?"test-code-and-testable-code":"/blog/post/test-code-and-testable-code.html",title:"测试代码和可测试代码",language:"zh_CN"}})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(r,{...e})}):r(e)}let d=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["..%2Fnode_modules%2F.rspress%2Fruntime%2Ftemp-30.mdx"]={toc:[{text:"2017-02-09 更新",id:"2017-02-09-更新",depth:2}],title:"测试代码和可测试代码",headingTitle:"测试代码和可测试代码",frontmatter:{category:null,tags:"Code",date:"2016-06-04T00:00:00.000Z",sidebar:!1,footer:!1}}}}]);