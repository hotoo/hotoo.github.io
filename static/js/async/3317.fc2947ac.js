"use strict";(self.webpackChunkhotoo_github_io=self.webpackChunkhotoo_github_io||[]).push([["3317"],{36610:function(n,e,r){r.r(e),r.d(e,{default:()=>s});var a=r(74132),i=r(40453);function l(n){let e=Object.assign({ul:"ul",li:"li",h1:"h1",a:"a",p:"p",blockquote:"blockquote",pre:"pre",code:"code"},(0,i.ah)(),n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{}),"\n"]}),"\n",(0,a.jsxs)(e.h1,{id:"阶乘factorial--尾递归tail-recursion",children:["阶乘(factorial) & 尾递归(Tail Recursion)",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#阶乘factorial--尾递归tail-recursion",children:"#"})]}),"\n",(0,a.jsxs)(e.p,{children:["今天看了dennis的《",(0,a.jsx)(e.a,{href:"http://www.blogjava.net/killme2008/archive/2008/03/18/187071.html",target:"_blank",rel:"noopener noreferrer",children:"用递归计算阶乘咋不行呢？"}),"》\n受益良多，这里做下小结。"]}),"\n",(0,a.jsx)(e.p,{children:"传统的递归算法写起来很漂亮，代码很简洁，但是每递归一次就需要更深一层的堆栈支持，\n可能会造成内存溢出而失败，所以递归和goto语句一样声名狼藉。"}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"甚至《代码大全》的作者有这样一句话：如果为我工作的程序员用递归去计算阶乘，那么我宁愿换人。\n作者对递归的态度相当谨慎，这在静态命令式语言中显然是正确的，但是在函数式语言中，\n由于有尾递归优化的存在，递归反而是最自然的形式，况且我打心里认为递归更符合人类思维。\n(by dennis)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"尾递归就是从最后开始计算，每递归一次就算出相应的结果，\n也就是说，函数调用出现在调用者函数的尾部，因为是尾部，\n所以根本没有必要去保存任何局部变量，直接让被调用的函数返回时越过调用者，\n返回到调用者的调用者去。举例说明。"}),"\n",(0,a.jsx)(e.p,{children:"线性递归（传统递归方式）："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function recursion(n){\n    return n==1?1:n*recursion(n-1);\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"尾递归："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function tailRecursion(n, a){\n    a = a||1; // 尾递归之尾，即上次递归结果。\n    return n==1?a:tailRecursion(n-1, a*n);\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"这里将基于尾递归的求数值阶乘算法贴下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"Math.factorial_III = function(n){\n    var a = arguments[1]||1;\n    return n<=1?a:Math.factorial_III(n-1, a*n);\n};\n"})}),"\n",(0,a.jsxs)(e.p,{children:["效率上和循环迭代、",(0,a.jsx)(e.a,{href:"http://blog.xianyun.org/2007/12/26/improved-factorial/",target:"_blank",rel:"noopener noreferrer",children:"阶乘改进算法"}),"\n相当甚至稍胜出（ie6,firefox2,safari3），普通递归的效率最为底下，且需要深入堆栈。"]}),"\n",(0,a.jsxs)(e.h1,{id:"参考",children:["参考",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#参考",children:"#"})]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["《",(0,a.jsx)(e.a,{href:"http://baike.baidu.com/view/1439396.htm",target:"_blank",rel:"noopener noreferrer",children:"尾递归"}),"》-百度百科"]}),"\n",(0,a.jsxs)(e.li,{children:["《",(0,a.jsx)(e.a,{href:"http://www.blogjava.net/killme2008/archive/2008/03/18/187071.html",target:"_blank",rel:"noopener noreferrer",children:"用递归计算阶乘咋不行呢？"}),"》-dennis"]}),"\n"]})]})}function t(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(l,{...n})}):l(n)}let s=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["blog%2Fpost%2F2008%2Ffactorial-recursion.md"]={toc:[],title:"参考",headingTitle:"参考",frontmatter:[{template:"post.html"},{date:"2008-04-08T00:00:00.000Z"},{tags:"算法"}]}}}]);