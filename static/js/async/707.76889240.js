"use strict";(self.webpackChunkhotoo_github_io=self.webpackChunkhotoo_github_io||[]).push([["707"],{5670:function(n,e,r){r.r(e),r.d(e,{default:()=>d});var s=r(4132),i=r(453);function t(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",img:"img",ol:"ol",li:"li",pre:"pre",code:"code",h3:"h3",footer:"footer",div:"div",strong:"strong",cite:"cite"},(0,i.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"每周异常第-6期javascript-异常监控脚本引发的-javascript-异常",children:["每周异常：第 6期，JavaScript 异常监控脚本引发的 JavaScript 异常",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#每周异常第-6期javascript-异常监控脚本引发的-javascript-异常",children:"#"})]}),"\n",(0,s.jsxs)(e.h2,{id:"背景",children:["背景",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#背景",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"早上收到比较重要的用户反馈说某个重要的系统的页面在 IE 浏览器中卡死，无法继续。"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.img,{src:"https://f.cloud.github.com/assets/143572/1007567/5214e9b4%5Cn0b0b%5Cn11e3%5Cn8d43%5Cn07d34947d198.png",alt:"2013\\\\n08\\\\n22 5 14 01"}),"\n",(0,s.jsx)(e.img,{src:"https://f.cloud.github.com/assets/143572/1007568/523e63de%5Cn0b0b%5Cn11e3%5Cn85bd%5Cnb3adee635aef.png",alt:"2013\\\\n08\\\\n22 5 14 25"})]}),"\n",(0,s.jsx)(e.p,{children:"问题很严重。"}),"\n",(0,s.jsx)(e.p,{children:"系统比较特殊复杂，不是一般人能登录进去的。找到对应同学在小概率重现的情况下终于拿到了第一手的问题源码。"}),"\n",(0,s.jsxs)(e.h2,{id:"分析",children:["分析",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#分析",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"修改配置和采样率之后在本地跑起来，发现在 IE6 里非常有问题。"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"性能这么大的问题，首先想到的是页面中大面积扫描 HTML 代码的部分，但是注释掉这部分仍然没有改善。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"再次把整个回调处理函数注释掉，仍然没有改善。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"直接把加载后置脚本的 seajs.use 注释掉之后，终于没问题了。（坑爹的缓存问题就不说了，好久之后才发现，都是泪~）"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"这么看来有两种可能："}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"模块本身有性能问题。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"seajs 性能有问题（这个问题页面目前使用的 1.3.1）"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"首先考虑自身的问题。return 整个 factory，性能无问题，因此不是模块过多导致 seajs 性能问题。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["逐步修改 return 位置（其实可以打断点），终于发现问题出在 ",(0,s.jsx)(e.a,{href:"https://github.com/totorojs/monitor.js/blob/2.2.0/src/monitor.js#L23",target:"_blank",rel:"noopener noreferrer",children:"初始化事件绑定函数部分"}),"。"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"// 避免未引用先行脚本抛出异常。\nif(!win.monitor){\n  M = win.monitor = {};\n  M.\\nDATAS = [];\n  M.\\nEVENTS = [];\n}\n\nvar \\nevents = M.\\nEVENTS;\nvar \\nevt = new Events();\nM.on = function(evt, handler){\n  \\nevt.on(evt, handler);\n};\nfor(var i=0,l=\\nevents.length; i<l; i++){\n  M.on(\\nevents[i][0], \\nevents[i][1]);\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"此时 \\nevents = undefined。访问 undefined.length 或其他属性会导致浏览器挂起？ IE6 还有这样的坑？"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:["新建一个最小代码的新页面，直接 ",(0,s.jsx)(e.code,{children:"script[src]"})," 引入这个脚本没有问题，IE 会正常的抛出异常，不会挂起。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"动态创建 script 插入脚本，仍然不会挂起，正常抛出异常。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"奇怪。各种尝试，最终加入前置脚本后在这个最小重现代码中重现了异常。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"然后发现是在 window.onerror 中出现问题。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"继续发现的模拟调用栈信息的算法出现问题。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["cmd 模块在 define 的 factory 中本身抛出异常，会被前置脚本的 window.onerror 捕获，捕获过程中尝试 ",(0,s.jsx)(e.a,{href:"https://github.com/totorojs/monitor.js/blob/2.2.0/src/seer.js#L66",target:"_blank",rel:"noopener noreferrer",children:"还原函数调用栈"}),"。模拟还原调用栈信息是通过 arguments.callee.caller 向上递归，直到找到函数调用的发起者。但是悲剧的是发现 seajs 这个调用栈是无穷无尽的："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"at function(require, exports, module)\nat function runInModuleContext(fn, module)\nat function()\nat function(uri)\nat function(item, i, arr)\nat function(arr, fn)  ........\\n\nat function(arr, fn)          |\nat function()                 |\nat function preload(callback) |\nat function()                 |\nat function cb(module)        |\nat function onFetched()       |\nat function(fn)       ........\\n\nat function(arr, fn)    ..........\\n\nat function(arr, fn)              | 循环往复\nat function()                     |\nat function preload(callback)     |\nat function()                     |\nat function cb(module)            |\nat function onFetched()           |\nat function(fn)         ..........\\n\nat function(arr, fn) .........\\n\nat function(arr, fn)          | 无穷尽也\nat function()                 |\nat function preload(callback) |\nat function()                 |\nat function cb(module)        |\nat function onFetched()       |\nat function(fn)         ......\\n\n"})}),"\n",(0,s.jsx)(e.p,{children:"这也就是为什么用户的浏览器会挂起的原因。"}),"\n",(0,s.jsx)(e.p,{children:"\\n\\n\\n\\n"}),"\n",(0,s.jsxs)(e.h3,{id:"小结",children:["小结",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"用户浏览器被挂起，最终发现："}),"\n",(0,s.jsx)(e.p,{children:"\\n 不是扫描整个文档的性能问题。\n\\n 不是 seajs 加载多个模块的性能问题。\n\\n 主要不是 cmd define 中报错的问题。\n\\n 不是 window.onerror 捕获异常的问题。\n\\n 而是获取异常函数调用栈出现无限循环链的问题，\n\\n 这其实是 IE 的问题。\n\\n 好吧，最终还是我的问题。"}),"\n",(0,s.jsxs)(e.h2,{id:"监控脚本自身的-cmd-模块定义的异常是怎么出现的",children:["监控脚本自身的 cmd 模块定义的异常是怎么出现的？",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#监控脚本自身的-cmd-模块定义的异常是怎么出现的",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["monitor 2.2.0 新增了 ",(0,s.jsx)(e.a,{href:"https://github.com/totorojs/monitor.js/issues/18",target:"_blank",rel:"noopener noreferrer",children:"事件机制"}),"，支持监控任意的自定义数据。"]}),"\n",(0,s.jsxs)(e.p,{children:["其中在前置脚本中新增了 ",(0,s.jsx)(e.code,{children:"monitor.on()"})," 方法，将自定义事件处理函数临时存储在 ",(0,s.jsx)(e.code,{children:"monitor.\\nEVENTS"})," 属性中 ",(0,s.jsx)(e.a,{href:"https://github.com/totorojs/monitor.js/blob/2.2.0/src/seer.js#L18",target:"_blank",rel:"noopener noreferrer",children:"参考代码"})," 。后置脚本加载完成后，会复写 ",(0,s.jsx)(e.code,{children:"monitor.on()"})," 方法，并将之前用户自定义事件处理函数绑定到对应事件，以使事件机制生效。"]}),"\n",(0,s.jsx)(e.p,{children:"这些理论上都是非常不错的设计思路。"}),"\n",(0,s.jsx)(e.p,{children:"但是现实太残酷，全站公共区域被实际部署的情况有太复杂："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"有些系统没有完全引入前置脚本。"}),"\n",(0,s.jsx)(e.li,{children:"有些系统仍然引用的老版本的前置脚本。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"后置脚本对于后面的这个场景没有考虑到，因此这段保险栓未能正确执行导致后续脚本报错。"}),"\n",(0,s.jsxs)(e.h2,{id:"为什么这个异常会到生产环境",children:["为什么这个异常会到生产环境？",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么这个异常会到生产环境",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"都是我的错，没有考虑周全。没有考虑到这种特殊的系统部署环境，而且我也从来不能进去实际体验、验证。"}),"\n",(0,s.jsxs)(e.h2,{id:"如何处理这个异常",children:["如何处理这个异常？",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#如何处理这个异常",children:"#"})]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"作为全站全局运行的代码，要详细评估考虑到各种系统变态的部署环境。"}),"\n",(0,s.jsx)(e.li,{children:"打断循环调用栈"}),"\n",(0,s.jsx)(e.li,{children:"限制监控的最大函数调用栈深度。"}),"\n",(0,s.jsx)(e.li,{children:"对于已经调用的栈，不再深入递归，或现在递归次数（待评估，实际项目存在正常的递归或多次调用的代码。）"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"为什么-seajs-define-模块中报错会出现函数调用栈无限递归",children:["为什么 seajs define 模块中报错会出现函数调用栈无限递归？",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么-seajs-define-模块中报错会出现函数调用栈无限递归",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["这是 seajs 1.3.1 的 BUG，更准确的说，可能是 IE6,7,8闭包的问题。参考： ",(0,s.jsx)(e.a,{href:"https://github.com/seajs/seajs/issues/911",target:"_blank",rel:"noopener noreferrer",children:"https://github.com/seajs/seajs/issues/911"})]}),"\n",(0,s.jsxs)("footer",{class:"blog-post-footer",children:[(0,s.jsx)("div",{class:"blog-post-footer-meta meta-left",children:(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Tags:"})," ",(0,s.jsx)("a",{href:"/blog/tags/%E6%AF%8F%E5%91%A8%E5%BC%82%E5%B8%B8",children:(0,s.jsx)("cite",{class:"tags",children:"每周异常"})})]})}),(0,s.jsx)("div",{class:"blog-post-footer-meta meta-right",children:(0,s.jsxs)(e.p,{children:["Published on ",(0,s.jsx)("cite",{class:"date",children:"2013-08-22"})]})})]})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(t,{...n})}):t(n)}let d=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["..%2Fnode_modules%2F.rspress%2Fruntime%2Ftemp-49.mdx"]={toc:[{text:"背景",id:"背景",depth:2},{text:"分析",id:"分析",depth:2},{text:"小结",id:"小结",depth:3},{text:"监控脚本自身的 cmd 模块定义的异常是怎么出现的？",id:"监控脚本自身的-cmd-模块定义的异常是怎么出现的",depth:2},{text:"为什么这个异常会到生产环境？",id:"为什么这个异常会到生产环境",depth:2},{text:"如何处理这个异常？",id:"如何处理这个异常",depth:2},{text:"为什么 seajs define 模块中报错会出现函数调用栈无限递归？",id:"为什么-seajs-define-模块中报错会出现函数调用栈无限递归",depth:2}],title:"每周异常：第 6期，JavaScript 异常监控脚本引发的 JavaScript 异常",headingTitle:"每周异常：第 6期，JavaScript 异常监控脚本引发的 JavaScript 异常",frontmatter:{category:null,tags:"每周异常",date:"2013-08-22T00:00:00.000Z"}}}}]);