"use strict";(self.webpackChunkhotoo_github_io=self.webpackChunkhotoo_github_io||[]).push([["808"],{7314:function(e,n,r){r.r(n),r.d(n,{default:()=>c});var s=r(74132),i=r(40453);function a(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",h2:"h2",ol:"ol",li:"li",hr:"hr",strong:"strong",cite:"cite",em:"em",footer:"footer",div:"div"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"javascript-分时加载",children:["JavaScript 分时加载",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript-分时加载",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"使用原始数据（非副本）和索引访问（非shift()），在IE中性能大幅度提高，\n其他浏览器对 concat()，尤其是 shift() 方法进行了优化，性能差别不大。"}),"\n",(0,s.jsx)(n.p,{children:"分时算法对于需要及时更新 UI 的情况非常有效，但是实际上分时算法性能非常不好\n（当然分时算法追求的不是这个），不适合作为巨量数据的实时处理。"}),"\n",(0,s.jsx)(n.p,{children:"譬如说在树形控件中，原始数据提供了一个巨大的数组数据："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'var datas = [\n    {id:"1", pid:"0", text:"Node 1"},\n    {id:"2", pid:"0", text:"Node 2"},\n    //...\n];\n'})}),"\n",(0,s.jsx)(n.p,{children:"我的处理方式是先将这份数据遍历一次，用 HashMap 进行缓存索引，便于后续的操作\n更加快捷。但是这个遍历本身是非常耗时的，虽然它不产生界面变化，但同样会将页面\n卡死。为了提高界面响应速度，我们会想到使用分时计算方式，不过这种方式会延长\n缓存索引的过程变的更久，导致后续创建节点的操作无法及时执行，也就无法更新界面，\n界面虽然可以操作，但是没什么可操作的（对于以树本身为主的页面来说）。"}),"\n",(0,s.jsx)(n.p,{children:"后来的做法是，根据树的实时装载能力（目前是十万个节点。经过缓存索引的数据，\n跟节点层级深度无关）和实际应用作出判断，对于在超出浏览器处理能力的，使用异步\n装载方式；处理能力以内的，不做要求。"}),"\n",(0,s.jsxs)(n.h2,{id:"延伸阅读",children:["延伸阅读",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#延伸阅读",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"http://lifesinger.googlecode.com/svn/trunk/lab/2009/array-processing.html",target:"_blank",rel:"noopener noreferrer",children:"http://lifesinger.googlecode.com/svn/trunk/lab/2009/array-processing.html"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"http://www.cnblogs.com/bluedream2009/archive/2010/03/16/1687095.html",target:"_blank",rel:"noopener noreferrer",children:"【优化】分时加载"})," - Cauma"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"http://www.nczonline.net/blog/2009/08/11/timed-array-processing-in-javascript/",target:"_blank",rel:"noopener noreferrer",children:"http://www.nczonline.net/blog/2009/08/11/timed-array-processing-in-javascript/"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Tags:"})," ",(0,s.jsx)("a",{href:"/blog/tags/JavaScript",children:(0,s.jsx)("cite",{class:"tags",children:"JavaScript"})}),", ",(0,s.jsx)("a",{href:"/blog/tags/UED",children:(0,s.jsx)("cite",{class:"tags",children:"UED"})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Published on 2011-03-01"})}),"\n",(0,s.jsxs)("footer",{children:[(0,s.jsx)("div",{class:"meta-left",children:(0,s.jsxs)(n.p,{children:["Tags: ",(0,s.jsx)("a",{href:"/blog/tags/JavaScript",children:(0,s.jsx)("cite",{class:"tags",children:"JavaScript"})}),", ",(0,s.jsx)("a",{href:"/blog/tags/UED",children:(0,s.jsx)("cite",{class:"tags",children:"UED"})})]})}),(0,s.jsx)("div",{class:"meta-right",children:(0,s.jsxs)(n.p,{children:["Date: ",(0,s.jsx)("cite",{class:"date",children:"2011-03-01"})]})})]})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}let c=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["..%2Fnode_modules%2F.rspress%2Fruntime%2Ftemp-98.mdx"]={toc:[{text:"延伸阅读",id:"延伸阅读",depth:2}],title:"JavaScript 分时加载",headingTitle:"JavaScript 分时加载",frontmatter:{}}}}]);