"use strict";(self.webpackChunkhotoo_github_io=self.webpackChunkhotoo_github_io||[]).push([["1326"],{759:function(n,e,t){t.r(e),t.d(e,{default:()=>c});var a=t(4132),r=t(453);function s(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",pre:"pre",blockquote:"blockquote",h2:"h2",footer:"footer",div:"div",strong:"strong",cite:"cite"},(0,r.ah)(),n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.h1,{id:"测试代码和可测试代码",children:["测试代码和可测试代码",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#测试代码和可测试代码",children:"#"})]}),"\n",(0,a.jsxs)(e.p,{children:["项目中有一个要将指定时间和当前时间比较，计算相对时间的逻辑（比如显示 ",(0,a.jsx)(e.code,{children:"3 分钟前"}),"），\n由于当前时间和执行测试用例的时机有关，每次执行用例都会不同，如何让这个代码可测试呢？\n有些人可能想到 Mock 当前时间，测试的时候让当前时间凝固，于是有了如下代码："]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"// 实际业务代码中：\n// 虽然本来只需要 moment() 就可以了，但是为了方便测试，传入了一个可 Mock 的 Date.now\nconst now = moment(Date.now());\n\n// 测试用例中，Mock Date.now 方法：\nmm(Date, 'now', () => 1464969293129);\n"})}),"\n",(0,a.jsx)(e.p,{children:"这个业务代码是 \\n\\n可测试\\n\\n 的代码吗？我认为不是。"}),"\n",(0,a.jsx)(e.p,{children:"这个业务代码为了测试，使用了一个不必要的方法，而且让测试代码和业务逻辑相互依赖，\n一旦业务代码重构，测试代码将不可测试。这个代码是为测试写的，称之为 \\n\\n测试\\n\\n 代码\n而不是 \\n\\n可测试\\n\\n 代码更合适点。"}),"\n",(0,a.jsx)(e.p,{children:"再举一个例子，还是时间相关的动态数据输入问题："}),"\n",(0,a.jsx)(e.p,{children:"项目中有一个今日收益更新的提醒消息，只有是今天的更新才显示，所以第一直觉应该是造一个\n收益更新时间是今天的测试数据，而不是造一个固定的数据（可能固定测试数据比较偷懒方便），\n然后篡改业务逻辑中当前时间的计算。"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"// 业务代码正常该怎么写怎么写，不用管测试怎么活。\nconst today = moment().format('YYYYMMDD');\nif (data.updateDate === today) {\n  // show message.\n}\n\n// 活的测试数据\ndata.updateDate = moment().format('YYYYMMDD');\n"})}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"测试代码应该只关注正常的数据输入和输出 \\n（即使输入、输出是难以预测的）\\n。"}),"\n",(0,a.jsx)(e.p,{children:"而不应该关注业务实现逻辑，试图篡改业务代码，让测试可以进行。"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"更好一点的可测试代码，可以将当前时间传入以便让输入、输出可以预测："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"// 业务抽象\n// 计算两个时间差，格式化为 `3 分钟前` 等相对时间。\n// @param {Date|Number} date1 较早的时间或时间戳。\n// @param {Date|Number} date2 较晚的时间或时间戳，默认当前时间。\n// @return {String} 相对时间差\nfunction dateDiff(date1, date2 = Date.now()) {\n  // ...\n}\n\n// 业务调用\ndateDiff(data.datetime);\n\n// 测试代码\nassert(dateDiff(new Date(2016,0,1,0,0,0,0), new Date(2016,0,1,0,0,0,10)) === '刚刚');\nassert(dateDiff(new Date(2016,0,1,0,0,0,0), new Date(2016,0,1,0,3,0,0)) === '3 分钟前');\nassert(dateDiff(new Date(2016,0,1,0,0,0,0), new Date(2016,0,1,1,0,0,0)) === '1 小时前');\n"})}),"\n",(0,a.jsxs)(e.h2,{id:"2017n02n09-更新",children:["2017\\n02\\n09 更新",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2017n02n09-更新",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"群里又有了类似的一个案例，开发想写测试用例来测 location.href 的赋值是否正确，\n用以测试页面跳转逻辑是否正确。于是想通过重载 location 对象来监听给 location.href\n赋值时，所赋值是否符合期望。"}),"\n",(0,a.jsxs)(e.p,{children:["还辛苦找到 ",(0,a.jsx)(e.a,{href:"https://zhuanlan.zhihu.com/p/24342684",target:"_blank",rel:"noopener noreferrer",children:"Chrome 出了个小 bug：论如何在 Chrome 下劫持原生只读对象"}),"\n这么牛逼变态到令人折服的方法。但是，这是正确的方法吗？我认为不是。"]}),"\n",(0,a.jsx)(e.p,{children:"location 的案例中，我觉得应该是测试赋值给 location.href 的 \\n\\n值\\n\\n本身是否正确，\n而不是测试企图篡改 location 来监听 href 属性是否正确。即："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-js",children:"// 业务代码\nfunction getUrl(){}\nlocation.href = getUrl(...args);\n"})}),"\n",(0,a.jsx)(e.p,{children:"单元测试用例只需要测试 getUrl 在各种边界输入条件下，输出是否符合期望就可以了。"}),"\n",(0,a.jsxs)("footer",{class:"blog-post-footer",children:[(0,a.jsx)("div",{class:"blog-post-footer-meta meta-left",children:(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Tags:"})," ",(0,a.jsx)("a",{href:"/blog/tags/Code",children:(0,a.jsx)("cite",{class:"tags",children:"Code"})})]})}),(0,a.jsx)("div",{class:"blog-post-footer-meta meta-right",children:(0,a.jsxs)(e.p,{children:["Published on ",(0,a.jsx)("cite",{class:"date",children:"2016-06-04"})]})})]})]})}function o(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,r.ah)(),n.components);return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(s,{...n})}):s(n)}let c=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["..%2Fnode_modules%2F.rspress%2Fruntime%2Ftemp-30.mdx"]={toc:[{text:"2017\\n02\\n09 更新",id:"2017n02n09-更新",depth:2}],title:"测试代码和可测试代码",headingTitle:"测试代码和可测试代码",frontmatter:{category:null,tags:"Code",date:"2016-06-04T00:00:00.000Z",sidebar:!1,footer:!1}}}}]);