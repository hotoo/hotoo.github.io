"use strict";(self.webpackChunkhotoo_github_io=self.webpackChunkhotoo_github_io||[]).push([["5066"],{73584:function(n,e,h){h.r(e),h.d(e,{default:()=>a});var i=h(74132),s=h(40453);function r(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ol:"ol",li:"li",h2:"h2"},(0,s.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.h1,{id:"面积分割算法",children:["面积分割算法",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#面积分割算法",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"做用户点击行为分析的展现时，用了一个透明的层覆盖在页面上，然后覆盖一层 canvas\n画布，使用稀疏矩阵算法绘制热点分布图。"}),"\n",(0,i.jsx)(e.p,{children:"预蒙上一层透明蒙版，然后只对需要的区域进行绘制热点图，本是非常不错的方案，我\n本机上也一直无问题。但是测试提交了一个 bug，说 IE 下看到点击热点图及轨迹图背后\n一片漆黑，我就猜测滤镜问题，最先猜想的是浏览器安全设置导致的滤镜无效，但是又\n发现有些类似的图形有没有问题。"}),"\n",(0,i.jsx)(e.p,{children:"结果发现是某些显卡下，IE 中超大面积的区域滤镜会失效。"}),"\n",(0,i.jsx)(e.p,{children:"首先想到的解决办法就是针对 IE 进行切割蒙版，由多个蒙版拼接而成，类似于铺地板。"}),"\n",(0,i.jsx)(e.p,{children:"普通的算法有两种："}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"将整块蒙版区域划分成多个 2000*2000 的蒙版，最后一列和最后一行不足指数，取余\n设置宽高。"}),"\n",(0,i.jsx)(e.li,{children:"将整块蒙版划分成多个不超过 2000*2000 的等份蒙版。这种算法比较简单，稍微的不足\n之处在于，不能除断的情况，无法等分。"}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"TODO: 有更灵巧的算法么，当然有了，只是我还不知道而已。"}),"\n",(0,i.jsxs)(e.h2,{id:"后来想到",children:["后来想到",(0,i.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#后来想到",children:"#"})]}),"\n",(0,i.jsx)(e.p,{children:"用 canvas 绘制一个透明的区域也未尝不可。"})]})}function t(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(r,{...n})}):r(n)}let a=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["blog%2Fpost%2F2011%2Farea-split.md"]={toc:[{text:"后来想到",id:"后来想到",depth:2}],title:"面积分割算法",headingTitle:"面积分割算法",frontmatter:{date:"2011-08-25T00:00:00.000Z",tags:"算法"}}}}]);