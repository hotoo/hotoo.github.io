"use strict";(self.webpackChunkhotoo_github_io=self.webpackChunkhotoo_github_io||[]).push([["7362"],{6426:function(n,e,r){r.r(e),r.d(e,{default:()=>l});var a=r(4132),s=r(453);function t(n){let e=Object.assign({h1:"h1",a:"a",p:"p",blockquote:"blockquote",pre:"pre",code:"code",footer:"footer",div:"div",strong:"strong",cite:"cite"},(0,s.ah)(),n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.h1,{id:"阶乘factorial--尾递归tail-recursion",children:["阶乘(factorial) & 尾递归(Tail Recursion)",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#阶乘factorial--尾递归tail-recursion",children:"#"})]}),"\n",(0,a.jsx)(e.p,{children:"\\n"}),"\n",(0,a.jsxs)(e.p,{children:["今天看了dennis的《",(0,a.jsx)(e.a,{href:"https://www.blogjava.net/killme2008/archive/2008/03/18/187071.html",target:"_blank",rel:"noopener noreferrer",children:"用递归计算阶乘咋不行呢？"}),"》\n受益良多，这里做下小结。"]}),"\n",(0,a.jsx)(e.p,{children:"传统的递归算法写起来很漂亮，代码很简洁，但是每递归一次就需要更深一层的堆栈支持，\n可能会造成内存溢出而失败，所以递归和goto语句一样声名狼藉。"}),"\n",(0,a.jsxs)(e.blockquote,{children:["\n",(0,a.jsx)(e.p,{children:"甚至《代码大全》的作者有这样一句话：如果为我工作的程序员用递归去计算阶乘，那么我宁愿换人。\n作者对递归的态度相当谨慎，这在静态命令式语言中显然是正确的，但是在函数式语言中，\n由于有尾递归优化的存在，递归反而是最自然的形式，况且我打心里认为递归更符合人类思维。\n(by dennis)"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"尾递归就是从最后开始计算，每递归一次就算出相应的结果，\n也就是说，函数调用出现在调用者函数的尾部，因为是尾部，\n所以根本没有必要去保存任何局部变量，直接让被调用的函数返回时越过调用者，\n返回到调用者的调用者去。举例说明。"}),"\n",(0,a.jsx)(e.p,{children:"线性递归（传统递归方式）："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function recursion(n){\n    return n==1?1:n\\nrecursion(n\\n1);\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"尾递归："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"function tailRecursion(n, a){\n    a = a||1; // 尾递归之尾，即上次递归结果。\n    return n==1?a:tailRecursion(n\\n1, a\\nn);\n}\n"})}),"\n",(0,a.jsx)(e.p,{children:"这里将基于尾递归的求数值阶乘算法贴下："}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-javascript",children:"Math.factorial\\nIII = function(n){\n    var a = arguments[1]||1;\n    return n<=1?a:Math.factorial\\nIII(n\\n1, a\\nn);\n};\n"})}),"\n",(0,a.jsxs)(e.p,{children:["效率上和循环迭代、",(0,a.jsx)(e.a,{href:"https://blog.xianyun.org/2007/12/26/improved%5Cnfactorial/",target:"_blank",rel:"noopener noreferrer",children:"阶乘改进算法"}),"\n相当甚至稍胜出（ie6,firefox2,safari3），普通递归的效率最为底下，且需要深入堆栈。"]}),"\n",(0,a.jsxs)(e.h1,{id:"参考",children:["参考",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#参考",children:"#"})]}),"\n",(0,a.jsxs)(e.p,{children:["\\n 《",(0,a.jsx)(e.a,{href:"https://baike.baidu.com/view/1439396.htm",target:"_blank",rel:"noopener noreferrer",children:"尾递归"}),"》\\n百度百科\n\\n 《",(0,a.jsx)(e.a,{href:"https://www.blogjava.net/killme2008/archive/2008/03/18/187071.html",target:"_blank",rel:"noopener noreferrer",children:"用递归计算阶乘咋不行呢？"}),"》\\ndennis"]}),"\n",(0,a.jsxs)("footer",{class:"blog-post-footer",children:[(0,a.jsx)("div",{class:"blog-post-footer-meta meta-left",children:(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Tags:"})," ",(0,a.jsx)("a",{href:"/blog/tags/%E7%AE%97%E6%B3%95",children:(0,a.jsx)("cite",{class:"tags",children:"算法"})})]})}),(0,a.jsx)("div",{class:"blog-post-footer-meta meta-right",children:(0,a.jsxs)(e.p,{children:["Published on ",(0,a.jsx)("cite",{class:"date",children:"2008-04-08"})]})})]})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(t,{...n})}):t(n)}let l=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["..%2Fnode_modules%2F.rspress%2Fruntime%2Ftemp-191.mdx"]={toc:[],title:"参考",headingTitle:"参考",frontmatter:{category:null,tags:"算法",date:"2008-04-08T00:00:00.000Z"}}}}]);