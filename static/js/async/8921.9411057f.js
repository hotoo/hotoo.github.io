"use strict";(self.webpackChunkhotoo_github_io=self.webpackChunkhotoo_github_io||[]).push([["8921"],{20425:function(r,n,e){e.r(n),e.d(n,{default:()=>l});var s=e(74132),a=e(40453);function t(r){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",h2:"h2",hr:"hr",strong:"strong",cite:"cite",em:"em",footer:"footer",div:"div"},(0,a.ah)(),r.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"多种不同结果的返回模式",children:["多种不同结果的返回模式",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#多种不同结果的返回模式",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"探讨个问题哈，我现在再做一个 HTML 校验工具，先将 HMTL 源码解析成 DOM 树，\n其间可能遇到语法错误，为了发现更多的错误，会跳到下一个分界点继续解析；\n然后将解析得到的 DOM 树返回给 lint 工具继续进行进一步的语法、语义解析。\n其过程是："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var dom = parse(html){cap(err); return dom;};\nvar lintErr = lint(dom){return err;};\n"})}),"\n",(0,s.jsx)(n.p,{children:"最终需要将 parse 和 lint 的错误收集到一起反馈给服务端。"}),"\n",(0,s.jsx)(n.p,{children:"请问，parse 有什么好的方式来返回解析时错误信息？"}),"\n",(0,s.jsx)(n.p,{children:"之前先是将 parse 设计成了函数式，但是我觉得下面这种返回方式很不好："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"return {\n    dom: dom,\n    err: err\n};\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"另外一种思路",children:["另外一种思路",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#另外一种思路",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"HTMLParser 设计成独立的类（而不是上面的函数方式）"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'var HTMLParser = function(){\n    var err = [];\n    this.parse = function(html){\n        var dom = {};\n\n        err.push(new Error("this is not error."));\n        err.push(new Error("err is not error."));\n\n        return dom;\n    };\n    this.getErrors = function(){\n        return err;\n    };\n};\n\nfunction main(html){\n    var parser = new HTMLParser();\n    var dom = parser.parse(html);\n    var err = parser.getErrors();\n    var result = HTMLint(dom);\n\n    // concat array to err.\n    Array.prototype.push.apply(err, result);\n\n    return err;\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"貌似这种方式比上面的稍好一点，不过我又不想为此将原本很简单的函数式改成\n对象式。"}),"\n",(0,s.jsxs)(n.h2,{id:"外部数据存储",children:["外部数据存储",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#外部数据存储",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'var Console = (function(){\n    var _err = [];\n    function log(err){\n        _err.push(err);\n    }\n    function getErr(){\n        return _err;\n    }\n\n    return {\n        log: log,\n        getErrors: getErr\n    };\n});\nvar HTMLParse = function(){\n    Console.log(new Error("syntax error."));\n    Console.log(new Error("parse error"));\n\n    return dom;\n};\nvar HTMLint = function(dom){\n    var err = [];\n    err.push(new Error("lint error."));\n    err.push(new Error("lint error."));\n    return err;\n};\nfunction main(html){\n    var dom = HTMLParse(html);\n    var parseErr = Console.getErrors();\n    var lintErr = HTMLint(dom);\n\n    Array.prototype.push.apply(parseErr, lintErr);\n\n    return parseErr;\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["对于只有一个实例（或运行一次）的情况，第三方独立的 ",(0,s.jsx)(n.code,{children:"console"})," 是合适的。\n但是一旦需要多个实例（或运行多次，每次Parse的结果都各自独立，\n每个html的parse和lint的错误结果各自拼接一起，但是不是所有的html的parse+lint错误结果拼接在一起）\n的情况，还是将解析异常信息和解析器本身绑定在一起（比如类）的方式比较合适。"]}),"\n",(0,s.jsx)(n.p,{children:"上面的文字有点绕，表达式："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"err0 = parseError0 + lintError0;\nerr1 = parseError1 + lintError1;\n"})}),"\n",(0,s.jsx)(n.p,{children:"err0 和 err1 是各自独立的，实例化多个第三方独立的有专用的Console，不如用类的方式好了。"}),"\n",(0,s.jsxs)(n.h2,{id:"寻求指教",children:["寻求指教",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#寻求指教",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"对于这种需要返回多种不同数据的函数式，\n如果你有其他的方案，欢迎回帖、回邮，或回博交流指导 ：）"}),"\n",(0,s.jsxs)(n.h2,{id:"更新-2013",children:["更新 (2013)",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#更新-2013",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"事件机制可能是最好的选择："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'parser.on("error", function(err){\n});\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Tags:"})," ",(0,s.jsx)("a",{href:"/blog/tags/设计模式",children:(0,s.jsx)("cite",{class:"tags",children:"设计模式"})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Published on 2011-06-08"})}),"\n",(0,s.jsxs)("footer",{children:[(0,s.jsx)("div",{class:"meta-left",children:(0,s.jsxs)(n.p,{children:["Tags: ",(0,s.jsx)("a",{href:"/blog/tags/设计模式",children:(0,s.jsx)("cite",{class:"tags",children:"设计模式"})})]})}),(0,s.jsx)("div",{class:"meta-right",children:(0,s.jsxs)(n.p,{children:["Date: ",(0,s.jsx)("cite",{class:"date",children:"2011-06-08"})]})})]})]})}function i(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),r.components);return n?(0,s.jsx)(n,{...r,children:(0,s.jsx)(t,{...r})}):t(r)}let l=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["..%2Fnode_modules%2F.rspress%2Fruntime%2Ftemp-91.mdx"]={toc:[{text:"另外一种思路",id:"另外一种思路",depth:2},{text:"外部数据存储",id:"外部数据存储",depth:2},{text:"寻求指教",id:"寻求指教",depth:2},{text:"更新 (2013)",id:"更新-2013",depth:2}],title:"多种不同结果的返回模式",headingTitle:"多种不同结果的返回模式",frontmatter:{category:null,tags:"设计模式",date:"2011-06-08T00:00:00.000Z"}}}}]);