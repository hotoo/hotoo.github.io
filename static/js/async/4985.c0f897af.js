"use strict";(self.webpackChunkhotoo_co=self.webpackChunkhotoo_co||[]).push([["4985"],{5248:function(n,e,r){r.r(e),r.d(e,{default:()=>l});var t=r(4132),i=r(453),s=r(3030);function a(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",pre:"pre",code:"code",ul:"ul",li:"li",footer:"footer",div:"div",strong:"strong",cite:"cite"},(0,i.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.h1,{id:"javascript-string-方法效率大比拼",children:["Javascript String 方法效率大比拼",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript-string-方法效率大比拼",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:["最初是通过 ",(0,t.jsx)(e.a,{href:"https://blog.csdn.net/meizz",target:"_blank",rel:"noopener noreferrer",children:"梅子"}),"（",(0,t.jsx)(e.a,{href:"https://www.meizz.com/",target:"_blank",rel:"noopener noreferrer",children:"梅花雪"}),"）\n关于大型字符串拼接效率（",(0,t.jsx)(e.a,{href:"https://blog.csdn.net/meizz/archive/2005/12/14/552260.aspx",target:"_blank",rel:"noopener noreferrer",children:"1"}),"，\n",(0,t.jsx)(e.a,{href:"https://blog.csdn.net/meizz/archive/2006/01/04/569805.aspx",target:"_blank",rel:"noopener noreferrer",children:"2"}),"）的研究得到启发，\n最近又看到 never-online 的 ",(0,t.jsx)(e.a,{href:"https://www.never-online.net/blog/article.asp?id=259",target:"_blank",rel:"noopener noreferrer",children:"从 trim 原型函数看js正则表达式的性能"}),"，\n里面有介绍正则表达式效率陷阱等问题，并提出解决方法。\n我向来对这些鸡毛蒜皮感兴趣，也开始对大型字符串各种方法实现的效率进行比较，\n并尝试提高这些方法的效率。"]}),"\n",(0,t.jsxs)(e.h2,{id:"大型字符串拼接",children:["大型字符串拼接",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#大型字符串拼接",children:"#"})]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.a,{href:"https://blog.csdn.net/meizz/archive/2005/12/14/552260.aspx",target:"_blank",rel:"noopener noreferrer",children:"如梅子所言"}),"，\n使用数组的join方法确实是最好的实现，可以根据这个思路设计StringBuilder, StringBuffer类。"]}),"\n",(0,t.jsxs)(e.h2,{id:"大型字符串trim",children:["大型字符串trim",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#大型字符串trim",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"其实never-online在他的文章里有一些说的不准确的地方，代码也不算很精炼。\n既然这是鸡毛蒜皮的小事，这些零碎东西当然要斤斤计较了。\n我很久以前有收集到这样一些实现，I："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"String.prototype.trim = function(){\nreturn this.replace(/(^\\s+)(\\s+$)/g, '');\n};\n"})}),"\n",(0,t.jsx)(e.p,{children:"为了避免正则表达式使用括号带来的消耗，可以写成这样，II："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"String.prototype.trim = function(){\n    return this.replace(/(?:^\\s+)(?:\\s+$)/g, '');\n};\n"})}),"\n",(0,t.jsx)(e.p,{children:"另外有一套实现是这样的，III："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"String.prototype.lTrim = function(){\n    return this.replace(/^\\s+/, '');\n};\nString.prototype.rTrim = function(){\n    return this.replace(/\\s+$/, '');\n};\nString.prototype.trim = function(){\n    return this.lTrim().rTrim();\n};\n"})}),"\n",(0,t.jsx)(e.p,{children:"其实调用函数也会多少有一点消耗，写成这样或许会快一点点（开个玩笑，这样写会带来\n一些冗余代码，这时候就需要基于效率（时间）、代码量（空间）和可维护性方面的考量了），IV："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"String.prototype.trim = function(){\nreturn this.replace(/^\\s+/, '').replace(/\\s+$/, '');\n};\n"})}),"\n",(0,t.jsx)(e.p,{children:"后来我对正则表达式有了更多的了解，知道了贪婪与非贪婪匹配，于是自作聪明写了这一段："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:'String.prototype.trim = function(){\nreturn this.replace(/^\\s*(.*?)\\s*$/, "$1"); // 两端空白字符贪婪匹配，中间字符非贪婪匹配。\n};\n'})}),"\n",(0,t.jsx)(e.p,{children:"我曾经为这段代码自鸣得意了好长一段时间，不过后来想到点号不包括换行符，字符串中间有换行符时，返回值就不正确了，于是不情愿的改成这样（多行模式效率也很低），V："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:'String.prototype.trim = function(){\nreturn this.replace(/^\\s*((?:.\\n)*?)\\s*$/, "$1");\n};\n'})}),"\n",(0,t.jsx)(e.p,{children:"谁知，这样的代码遇到大家伙时效率会一落千丈，哎，失败。"}),"\n",(0,t.jsx)(e.p,{children:"原以为String.replace方法比String.substr、String.substring效率低，于是想，只使用正则表达式获得两头（或者一头）的索引位置，然后使用substring方法取出子串，VI："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"String.prototype.trim = function(){\n    var l=this.length;\n    /^[\\s]*/.test(this);\n    // /(?=[^\\s])/.test(this);// -- never-online\n    var s = RegExp.lastIndex;\n    if(1==s && !Char.isBlank(this.charAt(0)))s=0;\n    if(s==l){return '';}\n    // /\\s*$/.test(this);\n    // var e=RegExp.index;\n    var e=$lastIndexOf(function(c){return !Char.isBlank(c);});\n    e=-1==e?l:e+1;\n    return this.substring(s,e);\n};\n"})}),"\n",(0,t.jsx)(e.p,{children:"而最土的方法，莫过于两头都使用循环获得索引了，VII："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"String.prototype.trim = function(){\n    var f=function(c){return !Char.isBlank(c);};\n    var l=this.length, s=this.$indexOf(f), e=this.$lastIndexOf(f);\n    if(-1==s)s=0;\n    e= -1==e?l:e+1;\n    return this.substring(s, e);\n};\n"})}),"\n",(0,t.jsx)(e.p,{children:"代码里老是for啊for的一大串，为了节省字节，而且有可能的话，也准备再优化一下循环，\n就实现了$indexOf和$lastIndexOf两个方法，可以传递一个返回boolean值的函数作为参数\n（本来还想也支持正则表达式参数的，想想以前扩展indexOf和lastIndexOf方法后的效率，\n就算了），这样就可以求得第一个非空白和最后一个非空白字符的位置了。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"String.prototype.$indexOf = function(f){\n    for(var i=0,c,l=this.length; i=0; i--){\n        c=this.charAt(i);\n        if(f(c)){return i;}\n    }\n    return -1;\n};\nString.prototype.$lastIndexOf = function(f){\n    for(var i=this.length-1,c; i>=0; i--){\n        c=this.charAt(i);\n        if(f(c)){return i;}\n    }\n    return -1;\n};\n"})}),"\n",(0,t.jsx)(e.p,{children:"至于说要扩展到支持更长子串和起始索引，以后有需要再说了（顺便说一下，子串越长，\n有优化算法可以得到更高效率）。"}),"\n",(0,t.jsx)(e.p,{children:"另一个辅助方法："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"var Char = {\n    isBlank:function(c){\n        //return /\\s/.test(c);\n        return ' '==c '\\t'==c '\\r\\n'==c '\\n'==c '\\r'==c;\n    }\n};\n"})}),"\n",(0,t.jsxs)(e.p,{children:["到了永不在线(",(0,t.jsx)(e.a,{href:"https://translate.google.com/translate_t#en%7Czh-CN%7Cnever-online",target:"_blank",rel:"noopener noreferrer",children:"Google Translate翻译为"}),"“永远在线”)的算法，VIII："]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"String.prototype.trim = function(){\n    var s = this.replace(/^\\s+/, '');\n    var l=s.length, e=l;\n    if(0==l){return '';}\n    for(var i=l-1; i>=0; i--){\n        if(!Char.isBlank(s.charAt(i))){\n            e=i+1;\n            break;\n        }\n    }\n    return this.substring(0,e);\n};\n"})}),"\n",(0,t.jsx)(e.p,{children:"最初这个算法让我很兴奋，直觉上，感觉这样效率肯定要高，不过事实并不是这么简单。"}),"\n",(0,t.jsx)(e.p,{children:"说到这些实现的效率，无法一概而论，因为不同的字符串，它们的效率比也大不同，甚至异乎寻常。"}),"\n",(0,t.jsx)(e.p,{children:"影响trim方法效率的，主要与字符串的总长度，前面空白字符串长度，后面空白字符串长度，\n以及前中后的比例有关。详细的效率对比表有时间再上，这里只简要提一下："}),"\n",(0,t.jsx)(e.p,{children:"对于较小的字符串，各种实现都有不错的表现，而对于大型字符串，则实现III,\nIV表现较为稳定，甚至可以处理超大型字符串（修正：之前有误写成I，II两个较为稳定）。"}),"\n",(0,t.jsxs)(e.h2,{id:"大型字符串字节长度",children:["大型字符串字节长度",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#大型字符串字节长度",children:"#"})]}),"\n",(0,t.jsx)(e.p,{children:"即双字节长度为2。注意：这个提法其实也不正确，Javascript是使用Unicode字符集的，\n所有的字符都（有可能）是双字节字符。将汉字等转换为双字节长度主要是为了某些应用。\n最土的方法还是循环遍历所有字符，I："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"String.prototype.bytes = function(){\n    var l=this.length, r=l, n=0xff;\n    for(var i=l; i>=0; i--){\n        if(this.charCodeAt(i)>n){\n            r++;\n        }\n    }\n    return r;\n};\n"})}),"\n",(0,t.jsx)(e.p,{children:"这里判断字符是否双字节有很多方法，效率较高的之间相差（大概）不大。"}),"\n",(0,t.jsx)(e.p,{children:"另一种实现则看起来很轻灵，寥寥几行，II："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:'String.prototype.bytes = function(){\nreturn this.replace(/[^\\x00-\\xff]/g,"xx").length;\n};\n'})}),"\n",(0,t.jsx)(e.p,{children:"多动脑子，则想法愈多（也常把简单的事情复杂化），我想如果可以快速取得表达式\n(双字节/单字节)匹配次数，两值相加应该比较高效，III："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:'String.prototype.bytes = function(){\n    return this.length+this.replace(/[\\x00-\\xff]/g,"").length;\n};\n'})}),"\n",(0,t.jsx)(e.p,{children:"IV："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:'String.prototype.bytes = function(){\n    return this.length+(this.match(/[^\\x00-\\xff]/g)"").length;\n};\n'})}),"\n",(0,t.jsx)(e.p,{children:"另外看到梅花雪用数组能提供字符串拼接速度，也想：把字符串split为数组，\n不想对大型字符串而言，这split一步就慢得不行。"}),"\n",(0,t.jsx)(e.p,{children:"bytes方法的效率：使用Javascript脚本循环大型字符串（I），确实远不如内置的\nreplace方法（II）快，而使用正则表达式match方法（IV）又比replace方法（III）稍快，\n排名第二。"}),"\n",(0,t.jsxs)(e.h2,{id:"总结",children:["总结：",(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"replace方法因匹配而被替换的子串愈长，效率愈低。"}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsx)(e.p,{children:"根据目标字符串，选择合适的实现。"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)("footer",{class:"blog-post-footer",children:[(0,t.jsx)("div",{class:"blog-post-footer-meta meta-left",children:(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Tags:"})," ",(0,t.jsx)("a",{href:"/blog/tags/JavaScript",children:(0,t.jsx)("cite",{class:"tags",children:"JavaScript"})}),", ",(0,t.jsx)("a",{href:"/blog/tags/%E6%80%A7%E8%83%BD",children:(0,t.jsx)("cite",{class:"tags",children:"性能"})}),", ",(0,t.jsx)("a",{href:"/blog/tags/%E7%AE%97%E6%B3%95",children:(0,t.jsx)("cite",{class:"tags",children:"算法"})})]})}),(0,t.jsx)("div",{class:"blog-post-footer-meta meta-right",children:(0,t.jsxs)(e.p,{children:["Published on ",(0,t.jsx)("cite",{class:"date",children:"2008-12-29"})]})})]}),"\n",(0,t.jsx)(s.DiscussionEmbed,{shortname:"hotoo",config:{url:"https://hotoo.co/blog/post/javascript-string.html",identifier:["github-gitlab-or-bitbucket","git-branch","vim-tutor","eventlistenerlist","gtalk-group-for-vim","dropbox-died-in-china","vim-chinese-doc"].includes("javascript-string")?"javascript-string":"/blog/post/javascript-string.html",title:"Javascript String 方法效率大比拼",language:"zh_CN"}})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(a,{...n})}):a(n)}let l=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["..%2Fnode_modules%2F.rspress%2Fruntime%2Ftemp-182.mdx"]={toc:[{text:"大型字符串拼接",id:"大型字符串拼接",depth:2},{text:"大型字符串trim",id:"大型字符串trim",depth:2},{text:"大型字符串字节长度",id:"大型字符串字节长度",depth:2},{text:"总结：",id:"总结",depth:2}],title:"Javascript String 方法效率大比拼",headingTitle:"Javascript String 方法效率大比拼",frontmatter:{category:null,tags:"JavaScript, 性能, 算法",date:"2008-12-29T00:00:00.000Z",sidebar:!1,footer:!1}}}}]);