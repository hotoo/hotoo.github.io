"use strict";(self.webpackChunkhotoo_github_io=self.webpackChunkhotoo_github_io||[]).push([["5854"],{65566:function(r,e,n){n.r(e),n.d(e,{default:()=>c});var a=n(74132),t=n(40453);function s(r){let e=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",code:"code",h2:"h2"},(0,t.ah)(),r.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.h1,{id:"arguments-to-array-之效率",children:["arguments to Array 之效率",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#arguments-to-array-之效率",children:"#"})]}),"\n",(0,a.jsxs)(e.p,{children:["怿飞昨天发有一篇《",(0,a.jsx)(e.a,{href:"https://www.planabc.net/2010/01/06/arguments_to_array/",target:"_blank",rel:"noopener noreferrer",children:"如何将函数的实际参数转换成数组"}),"》\r\n的日志，其实核心不是讲“如何如何”，而是比较了几种算法/语法的效率。\r\n说到算法本身的性能，我和 ",(0,a.jsx)(e.a,{href:"https://www.planabc.net/2010/01/06/arguments_to_array/#comment-5869",target:"_blank",rel:"noopener noreferrer",children:"army 的看法"}),"\r\n一样，对这篇日志的观点提出质疑。"]}),"\n",(0,a.jsx)(e.p,{children:"从语法原理上，Array.prototype.slice.call(arguments)是对数组的slice方法的原型直接引用，而[].slice.call(arguments)则需要创建数组对象。没有理由后者比前者的性能还要高的。"}),"\n",(0,a.jsxs)(e.p,{children:["不过我还是写了 ",(0,a.jsx)(e.a,{href:"https://hotoo.googlecode.com/svn/trunk/test/toArray.html",target:"_blank",rel:"noopener noreferrer",children:"测试"}),"\r\n来证实自己的观点，为了尽量少的避免其他干扰（包括函数调用带来的消耗），\r\n算法/语法都直接内联写在计时器一起。"]}),"\n",(0,a.jsx)(e.p,{children:"这几个例子分别比较了："}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.code,{children:"Array.apply(this,arguments)"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.code,{children:"Array.prototype.slice.call(arguments)"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.code,{children:"[].slice.call(arguments)"})}),"\n",(0,a.jsxs)(e.li,{children:["Prototype 的 ",(0,a.jsx)(e.code,{children:"$A(arguments)"})]}),"\n",(0,a.jsxs)(e.li,{children:["jQuery 的 ",(0,a.jsx)(e.code,{children:"makeArray(arguments)"})]}),"\n",(0,a.jsx)(e.li,{children:"和最土的循环算法。"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"并在各个浏览器（Multi IE 6, IETester 5.5, IETester 6, IE 7, FF 3.5, Chrome 4,\r\nSafari 4, Opera 10）下一一测试。也欢迎各位参与测试并将结果提交给我，\r\n如果你觉得测试有不公平合理的地方也可以提出。"}),"\n",(0,a.jsxs)(e.p,{children:["至于结论，也不是那么好确定，不过大致如下：\r\n",(0,a.jsx)(e.code,{children:"Array.apply(this,arguments)"})," 在大部分情况下都能取得优胜；\r\n而Prototype和jQuery其次，不过这两者不仅仅是针对arguments编写而且是直接调用其函数\r\n（稍有消耗），这里只拿来比较一下，这两个还是非常出色的；\r\n",(0,a.jsx)(e.code,{children:"Array.prototype.slice.call(arguments)"})," 和 ",(0,a.jsx)(e.code,{children:"[].slice"}),".call(arguments)则旗鼓相当，\r\n并没有说谁比谁一定更强，更浏览器实现有关，在部分浏览器中前者有稳定的微量优势；\r\n至于老土的循环法，",(0,a.jsx)(e.code,{children:"arguments.length"})," 较小时表现不俗，较大时也更浏览器有关系。\r\n而怿飞说的那点（不确定的）非关键或巨大性能优势，其实意义不大。"]}),"\n",(0,a.jsxs)(e.h2,{id:"延伸阅读",children:["延伸阅读：",(0,a.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#延伸阅读",children:"#"})]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"/javascript-regexp-concat-and-0-length-object.html",children:"正则表达式拼接和构建零长度对象"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"/javascript-string.html",children:"Javascript String 方法效率大比拼"})}),"\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"/efficiency-of-javascript-equals.html",children:"Javascript 相等符(==)与完全相等符(===)之效率"})}),"\n"]})]})}function l(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),r.components);return e?(0,a.jsx)(e,{...r,children:(0,a.jsx)(s,{...r})}):s(r)}let c=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["blog%2Fpost%2F2010%2Fperformance-of-arguments-to-array.md"]={toc:[{text:"延伸阅读：",id:"延伸阅读",depth:2}],title:"arguments to Array 之效率",headingTitle:"arguments to Array 之效率",frontmatter:{date:"2010-01-07T00:00:00.000Z",tags:"JavaScript, 性能"}}}}]);