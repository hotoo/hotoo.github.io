"use strict";(self.webpackChunkhotoo_github_io=self.webpackChunkhotoo_github_io||[]).push([["6261"],{20806:function(e,r,n){n.r(r),n.d(r,{default:()=>o});var i=n(74132),s=n(40453);function c(e){let r=Object.assign({h1:"h1",a:"a",p:"p",code:"code",h2:"h2",ul:"ul",li:"li",img:"img",hr:"hr",strong:"strong",cite:"cite",em:"em",footer:"footer",div:"div"},(0,s.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(r.h1,{id:"译严重混乱的-resource-timing",children:["译：严重混乱的 Resource Timing",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#译严重混乱的-resource-timing",children:"#"})]}),"\n",(0,i.jsxs)(r.h1,{id:"或者说耗时包含了-blocking-部分的时间",children:["或者说『耗时包含了 Blocking 部分的时间』",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#或者说耗时包含了-blocking-部分的时间",children:"#"})]}),"\n",(0,i.jsxs)(r.p,{children:["用 ",(0,i.jsx)(r.a,{href:"http://www.w3.org/TR/resource-timing/",target:"_blank",rel:"noopener noreferrer",children:"Resource Timing"})," 来同统计资源下载性能\n是非常赞的方式，但不幸的是，几乎所有和我聊过的人都是使用 ",(0,i.jsxs)(r.a,{href:"http://www.w3.org/TR/resource-timing/#duration-attribute",target:"_blank",rel:"noopener noreferrer",children:[(0,i.jsx)(r.code,{children:"duration"})," 属性"]}),"，\n而且他们都没有意识到 ",(0,i.jsx)(r.code,{children:"duration"})," 包含了 blocking 时间。结果 ",(0,i.jsx)(r.code,{children:"duration"})," 时间\n比实际的下载时间要长很多，超出了开发者意料之外的结果。这个问题在跨域资源中\n尤为糟糕，",(0,i.jsx)(r.code,{children:"duration"})," 是唯一可用的。在这篇博文中我将解释这个问题，并提出解决方案。"]}),"\n",(0,i.jsxs)(r.h2,{id:"resource-timing-回顾",children:["Resource Timing 回顾",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#resource-timing-回顾",children:"#"})]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.a,{href:"http://www.w3.org/TR/resource-timing/",target:"_blank",rel:"noopener noreferrer",children:"Resource Timing 规范"})," 定义了收集网页中\n所有资源耗时统计的 API。现在可用于 Chrome, Chrome for Android, IE 10-11, 和 Opera。\n可以通过 ",(0,i.jsx)(r.code,{children:"getEntries()"}),", ",(0,i.jsx)(r.code,{children:"getEntriesByType()"})," 和 ",(0,i.jsx)(r.code,{children:"getEntriesByName()"})," 得到一个\n",(0,i.jsx)(r.code,{children:"PerformanceEntry"})," 列表，一个 ",(0,i.jsx)(r.code,{children:"PerformanceEntry"})," 对象包含以下属性："]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"name"})," – URL 地址"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"entryType"})," – 通常是 “resource”"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"startTime"})," – 开始处理这个资源的时间（相对开始导航到页面时的毫秒数）"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.code,{children:"duration"})," – 处理这个资源的总耗时（毫秒）"]}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["上面的属性在所有的资源中都可用，包括同域和跨域的。而同域的资源拥有另外一些可以\n访问的附加属性，这些属性定义在 ",(0,i.jsx)(r.code,{children:"PerformanceResourceTiming"})," 接口中。这些属性名称\n很简洁清晰，完全可以见名思意，并且以时间顺序排序："]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"redirectStart"}),"\n",(0,i.jsx)(r.li,{children:"redirectEnd"}),"\n",(0,i.jsx)(r.li,{children:"fetchStart"}),"\n",(0,i.jsx)(r.li,{children:"domainLookupStart"}),"\n",(0,i.jsx)(r.li,{children:"domainLookupEnd"}),"\n",(0,i.jsx)(r.li,{children:"connectStart"}),"\n",(0,i.jsx)(r.li,{children:"connectEnd"}),"\n",(0,i.jsx)(r.li,{children:"secureConnectionStart"}),"\n",(0,i.jsx)(r.li,{children:"requestStart"}),"\n",(0,i.jsx)(r.li,{children:"responseStart"}),"\n",(0,i.jsx)(r.li,{children:"responseEnd"}),"\n"]}),"\n",(0,i.jsxs)(r.p,{children:["这里有个权威的 ",(0,i.jsx)(r.a,{href:"http://www.w3.org/TR/resource-timing/#processing-model",target:"_blank",rel:"noopener noreferrer",children:"处理模型(processing model)"})," 图\n显示了这些属性所在的各个不同阶段。备注：",(0,i.jsx)(r.code,{children:"duration"})," 相当于 ",(0,i.jsx)(r.code,{children:"responseEnd - startTime"}),"。"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.img,{src:"http://www.w3.org/TR/resource-timing/resource-timing-overview.png",alt:"processing model graphic"})}),"\n",(0,i.jsxs)(r.p,{children:["如何使用 Resource Timing 的详细信息，可以参考我的文章 ",(0,i.jsx)(r.a,{href:"http://www.stevesouders.com/blog/2014/08/21/resource-timing-practical-tips/",target:"_blank",rel:"noopener noreferrer",children:"Resource Timing Practical Tips"})," 『",(0,i.jsx)(r.a,{href:"./resource-timing-practical-tips",children:"译者的中文翻译"}),"』"]}),"\n",(0,i.jsxs)(r.h2,{id:"duration-中出乎意外的-blocking-膨胀",children:[(0,i.jsx)(r.code,{children:"duration"})," 中出乎意外的 blocking 膨胀",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#duration-中出乎意外的-blocking-膨胀",children:"#"})]}),"\n",(0,i.jsxs)(r.p,{children:["出于隐私的考虑，同源资源的 PerformanceResourceTiming 属性是受限的。（备注：\n任何资源可以通过 ",(0,i.jsx)(r.code,{children:"Timing-Allow-Origin"})," 响应头达到“同源”效果。）现在大约有一半\n的资源是跨域的，因此 ",(0,i.jsx)(r.code,{children:"duration"})," 是度量加载时间的唯一方式。而且即使是同源资源，\n",(0,i.jsx)(r.code,{children:"duration"})," 也是唯一以增量方式提供的属性，大概是因为它度量了最重要的阶段。\n这样一来，所有我见过的 Resource Timing 实现都以 ",(0,i.jsx)(r.code,{children:"duration"})," 做为主要的性能指标。"]}),"\n",(0,i.jsxs)(r.p,{children:["不幸的是，",(0,i.jsx)(r.code,{children:"duration"})," 比下载时间要大，它包含了阻塞时间（blocking time）—— 浏览器\n意识到需要下载一个资源，到这个资源实际被下载直接的时间延迟。阻塞会在几种情况时\n发生，最典型的资源数量比 TCP 连接数要多的情况。大多数浏览器为每个主机开放了 6\n个 TCP 连接，IE10（8个连接）和 IE11（12个连接）例外。"]}),"\n",(0,i.jsxs)(r.p,{children:["这个 ",(0,i.jsx)(r.a,{href:"http://stevesouders.com/tests/rt-blocking.php",target:"_blank",rel:"noopener noreferrer",children:"Resource Timing 阻塞测试页面"}),"\n有 16 个图片，因此无论哪个浏览器都会阻塞一部分图片。每个图片被编程为在服务器\n有 1 秒的延迟，这 16 个图片，每个图片都显示了 ",(0,i.jsx)(r.code,{children:"startTime"})," 和 ",(0,i.jsx)(r.code,{children:"duration"}),"。\n另外还有这个测试页面在 WebPagetest 中通过 ",(0,i.jsx)(r.a,{href:"http://www.webpagetest.org/result/141125_4T_11FT/",target:"_blank",rel:"noopener noreferrer",children:"Chrome"}),",\n",(0,i.jsx)(r.a,{href:"http://www.webpagetest.org/result/141125_BN_11FY/",target:"_blank",rel:"noopener noreferrer",children:"IE10"})," 和\n",(0,i.jsx)(r.a,{href:"http://www.webpagetest.org/result/141125_5K_11CB/",target:"_blank",rel:"noopener noreferrer",children:"IE11"})," 加载的测试结果，\n可以通过查看截屏来分析时序结果。注，为什么所有的图片的 ",(0,i.jsx)(r.code,{children:"startTime"})," 大致都相同？\n英文这个时间是浏览器解析 IMG 标签并意识到需要下载改资源的时间，由于先下载的图片\n阻塞的原因，但在页面出现后，图片的 ",(0,i.jsx)(r.code,{children:"duration"})," 值大约步进 1 秒左右。"]}),"\n",(0,i.jsxs)(r.h2,{id:"译者补充",children:["译者补充",(0,i.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#译者补充",children:"#"})]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.a,{href:"http://www.stevesouders.com/blog/2014/11/25/serious-confusion-with-resource-timing/",target:"_blank",rel:"noopener noreferrer",children:"SERIOUS CONFUSION with Resource Timing"})," - 原文出处。"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Tags:"})," ",(0,i.jsx)("a",{href:"/blog/tags/HTML5",children:(0,i.jsx)("cite",{class:"tags",children:"HTML5"})}),", ",(0,i.jsx)("a",{href:"/blog/tags/翻译",children:(0,i.jsx)("cite",{class:"tags",children:"翻译"})})]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.em,{children:"Published on 2014-12-30"})}),"\n",(0,i.jsxs)("footer",{children:[(0,i.jsx)("div",{class:"meta-left",children:(0,i.jsxs)(r.p,{children:["Tags: ",(0,i.jsx)("a",{href:"/blog/tags/HTML5",children:(0,i.jsx)("cite",{class:"tags",children:"HTML5"})}),", ",(0,i.jsx)("a",{href:"/blog/tags/翻译",children:(0,i.jsx)("cite",{class:"tags",children:"翻译"})})]})}),(0,i.jsx)("div",{class:"meta-right",children:(0,i.jsxs)(r.p,{children:["Date: ",(0,i.jsx)("cite",{class:"date",children:"2014-12-30"})]})})]})]})}function t(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,s.ah)(),e.components);return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}let o=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["..%2Fnode_modules%2F.rspress%2Fruntime%2Ftemp-37.mdx"]={toc:[{text:"Resource Timing 回顾",id:"resource-timing-回顾",depth:2},{text:"`duration` 中出乎意外的 blocking 膨胀",id:"duration-中出乎意外的-blocking-膨胀",depth:2},{text:"译者补充",id:"译者补充",depth:2}],title:"或者说『耗时包含了 Blocking 部分的时间』",headingTitle:"或者说『耗时包含了 Blocking 部分的时间』",frontmatter:{}}}}]);