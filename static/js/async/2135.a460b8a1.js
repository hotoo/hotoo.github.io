"use strict";(self.webpackChunkhotoo_github_io=self.webpackChunkhotoo_github_io||[]).push([["2135"],{8961:function(n,s,e){e.r(s),e.d(s,{default:()=>o});var a=e(4132),l=e(453);function i(n){let s=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",h2:"h2",ol:"ol",li:"li",footer:"footer",div:"div",strong:"strong",cite:"cite"},(0,l.ah)(),n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(s.h1,{id:"html-tabs-最佳实践",children:["HTML Tabs 最佳实践",(0,a.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#html-tabs-最佳实践",children:"#"})]}),"\n",(0,a.jsx)(s.p,{children:"Tabs 面板的显示和隐藏一般以 display 来控制显示和隐藏，但是如果默认未显示的 Tabs 面板中渲染需要知道面板宽高的组件\n（如 Canvas，某些轮播组件等）时，就会因为面板在 display:none 的状态下无法拿到宽高导致渲染组件异常。"}),"\n",(0,a.jsx)(s.p,{children:"这里建议 Tabs 使用 position:absolute 来将不可见的组件移动到用户不可见的负坐标区域，需要时再将面板移动到可见区域，\n来避免面板不可见时渲染内部组件异常的问题。而且也可以做一些滑动显示的动画效果。"}),"\n",(0,a.jsx)(s.p,{children:"简单示例代码："}),"\n",(0,a.jsx)(s.p,{children:"HTML:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-html",children:'<div class="tabs">\n  <ol class="tabbar">\n    <li class="active"><a href="#tab1">Tab 1</a></li>\n    <li><a href="#tab2">Tab 2</a></li>\n  </ol>\n  <ol class="tabpanel">\n    <li class="active">\n      Tab Panel 1\n    </li>\n    <li>\n      Tab Panel 2\n    </li>\n  </ol>\n</div>\n'})}),"\n",(0,a.jsx)(s.p,{children:"LESS:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-less",children:".tabs {\n  .tabpanel {\n    position: relative;\n    li {\n      position: absolute;\n      top: \\n999999px;\n      left: \\n9999px;\n      width: 100%; /\\n 避免浮动导致宽度不对 \\n/\n    }\n    li.active {\n      /\\n 不要使用 position:absolute 并且改变坐标的方式，\n       \\n 避免 Tabs 脱离文档流，父元素高度为 0，导致下面的其他元素错位。\n       \\n/\n      position: static;\n    }\n  }\n}\n"})}),"\n",(0,a.jsxs)(s.h2,{id:"切换-tab-时面板所在位置问题",children:["切换 Tab 时，面板所在位置问题",(0,a.jsx)(s.a,{className:"header-anchor","aria-hidden":"true",href:"#切换-tab-时面板所在位置问题",children:"#"})]}),"\n",(0,a.jsx)(s.p,{children:"无论使用 display 还是 position 方案，切换 tab 的时候，面板的位置会停留在上个显示的面板离开时的同一位置（默认是 0）。"}),"\n",(0,a.jsx)(s.p,{children:"有两个解决方案："}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:"对于可以固定面板高度的场景（如整个页面都是 Tab），固定面板容器的高度，则 position 方案在切换 Tab 的时候，\n默认就定位在当前面板之前停留的位置，但是需要使用 iScroll 类似的方案来实现上下拉回弹，及刷新、加载更多的功能\n（也可以使用 Native 默认的上下拉回弹功能，但是 Tabbar 会随着整个 webview 一起拉动，体验不是太好）。"}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:"切换 Tab 时，记录各个面板的所在位置，切换回来时使用 scrollTo(x, y) 的方式来滚动到面板上次的位置。"}),"\n",(0,a.jsxs)("footer",{class:"blog-post-footer",children:[(0,a.jsx)("div",{class:"blog-post-footer-meta meta-left",children:(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.strong,{children:"Tags:"})," ",(0,a.jsx)("a",{href:"/blog/tags/Code",children:(0,a.jsx)("cite",{class:"tags",children:"Code"})}),", ",(0,a.jsx)("a",{href:"/blog/tags/Tabs",children:(0,a.jsx)("cite",{class:"tags",children:"Tabs"})})]})}),(0,a.jsx)("div",{class:"blog-post-footer-meta meta-right",children:(0,a.jsxs)(s.p,{children:["Published on ",(0,a.jsx)("cite",{class:"date",children:"2017-03-21"})]})})]}),"\n"]}),"\n"]})]})}function t(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,l.ah)(),n.components);return s?(0,a.jsx)(s,{...n,children:(0,a.jsx)(i,{...n})}):i(n)}let o=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["..%2Fnode_modules%2F.rspress%2Fruntime%2Ftemp-28.mdx"]={toc:[{text:"切换 Tab 时，面板所在位置问题",id:"切换-tab-时面板所在位置问题",depth:2}],title:"HTML Tabs 最佳实践",headingTitle:"HTML Tabs 最佳实践",frontmatter:{category:null,tags:"Code, Tabs",date:"2017-03-21T00:00:00.000Z",sidebar:!1,footer:!1}}}}]);