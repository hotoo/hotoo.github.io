"use strict";(self.webpackChunkhotoo_co=self.webpackChunkhotoo_co||[]).push([["2460"],{9135:function(e,n,r){r.r(n),r.d(n,{default:()=>a});var i=r(4132),s=r(453),o=r(3030);function t(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",h2:"h2",ul:"ul",li:"li",blockquote:"blockquote",footer:"footer",div:"div",strong:"strong",cite:"cite"},(0,s.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"译resource-timing-资源计时-使用技巧",children:["译：Resource Timing (资源计时) 使用技巧",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#译resource-timing-资源计时-使用技巧",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://www.w3.org/2010/webperf/",target:"_blank",rel:"noopener noreferrer",children:"W3C Web 性能工作组"})," 在 2012 年给我们带来了\n",(0,i.jsx)(n.a,{href:"https://www.w3.org/TR/navigation-timing/",target:"_blank",rel:"noopener noreferrer",children:"Navigation Timing"}),"，这个 API 现在\n基本上在主流浏览器上都可用。Navigation Timing 定义了一套用于测量主页面性能的\nJavaScript API。例如："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"// Navigation Timing\nvar t = performance.timing,\n    pageloadtime = t.loadEventStart - t.navigationStart,\n    dns = t.domainLookupEnd - t.domainLookupStart,\n    tcp = t.connectEnd - t.connectStart,\n    ttfb = t.responseStart - t.navigationStart;\n"})}),"\n",(0,i.jsx)(n.p,{children:"能够度量主页面的时间消耗真是太棒了，但是要诊断现实当中的性能问题，往往需要深入\n到各个资源当中。所以我们拥有了更进一步的 Resource Timing （资源计时）规范，\n这个 JavaScript API 提供类似 Navigation Timing 的功能，但是能精确到每一个资源的\n耗时。举个例子："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'// Resource Timing\nvar r0 = performance.getEntriesByType("resource")[0],\n    loadtime = r0.duration,\n    dns = r0.domainLookupEnd - r0.domainLookupStart,\n    tcp = r0.connectEnd - r0.connectStart,\n    ttfb = r0.responseStart - r0.startTime;\n'})}),"\n",(0,i.jsx)(n.p,{children:"到目前为止，Chrome, Chrome for Android, Opera, IE10 和 IE11\n浏览器都支持 Resource Timing，这也许超过了你的网站 50% 的流量。\n这应该可以提供足够的数据，来揭示这些资源缓慢的原因。"}),"\n",(0,i.jsx)(n.p,{children:"使用 Resource Timing 看似很简单，但是当我在写第一个用于生产环境的 Resource Timing 代码\n时，遇到了许多问题。这里我想分享一些现实当中记录 Resource Timing 指标的实用技巧。"}),"\n",(0,i.jsxs)(n.h2,{id:"1-使用-getentriesbytyperesource-而不是-getentries",children:["1. 使用 ",(0,i.jsx)(n.code,{children:'getEntriesByType("resource")'})," 而不是 ",(0,i.jsx)(n.code,{children:"getEntries()"}),(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-使用-getentriesbytyperesource-而不是-getentries",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["在使用 Resource Timing 来获取当前页面的资源集合的资源耗时性能对象时，许多 Resource\nTiming 示例都是使用 ",(0,i.jsx)(n.code,{children:"performance.getEntries()"}),"，这意味着唯一的 resource timing 对象\n由该调用进行返回。但是 ",(0,i.jsx)(n.code,{children:"getEntries()"})," 会一并返回潜在的 ",(0,i.jsx)(n.a,{href:"https://www.w3.org/wiki/Web_Performance/EntryType",target:"_blank",rel:"noopener noreferrer",children:"4 种类型的 timing 对象"}),"：\n",(0,i.jsx)(n.code,{children:"resource"}),"（资源），",(0,i.jsx)(n.code,{children:"navigation"})," （导航）, ",(0,i.jsx)(n.code,{children:"mark"})," （标记）, 和 ",(0,i.jsx)(n.code,{children:"measure"})," （测量）。"]}),"\n",(0,i.jsxs)(n.p,{children:["这并没有造成多大问题，因为目前 ",(0,i.jsx)(n.code,{children:"resource"})," 是大多数网页的唯一类型。\n",(0,i.jsx)(n.code,{children:"navigation"})," 类型是 ",(0,i.jsx)(n.a,{href:"https://www.w3.org/TR/navigation-timing-2/",target:"_blank",rel:"noopener noreferrer",children:"Navigation Timing 2"})," 的一部分，据我所知目前没有被任何浏览器所实现。\n",(0,i.jsx)(n.code,{children:"mark"})," 和 ",(0,i.jsx)(n.code,{children:"measure"})," 类型是从 ",(0,i.jsx)(n.a,{href:"https://www.w3.org/TR/user-timing/",target:"_blank",rel:"noopener noreferrer",children:"User Timing"})," 规范衍生出来的，在部分浏览器中可用，\n但是还没有被广泛使用。"]}),"\n",(0,i.jsxs)(n.p,{children:["也就是说，",(0,i.jsx)(n.code,{children:'getEntriesByType("resource")'})," 以及 ",(0,i.jsx)(n.code,{children:"getEntries()"})," 在今天可能返回相同\n的结果，但是可能 ",(0,i.jsx)(n.code,{children:"getEntries()"})," 将很快返回多种性能对象的混合集合，所以最好是\n使用 ",(0,i.jsx)(n.code,{children:'performance.getEntriesByType("resource")'}),"，你可以明确的只获取 resource\ntiming 对象。（感谢 ",(0,i.jsx)(n.a,{href:"https://calendar.perfplanet.com/2012/an-introduction-to-the-resource-timing-api/",target:"_blank",rel:"noopener noreferrer",children:"Andy Davies"})," 给我解释这一点）"]}),"\n",(0,i.jsxs)(n.h2,{id:"2-使用-navigation-timing-测量主页面的请求",children:["2. 使用 Navigation Timing 测量主页面的请求。",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-使用-navigation-timing-测量主页面的请求",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["当通过典型的请求获取一个网页的主 HTML 文档，但是这个资源并不能通过\n",(0,i.jsx)(n.code,{children:'performance.getEntriesByType("resource")'})," 得到返回，要得到这个主页面 HTML 文档\n的 timing 信息，需要使用 Navigation Timing 对象（",(0,i.jsx)(n.code,{children:"performance.timing"}),"）。"]}),"\n",(0,i.jsx)(n.p,{children:"虽然不太可能，当页面上没有其他资源时，这可能会导致错误发生。\n例如，刚才 Resource Timing 示例使用如下代码："}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'performance.getEntriesByType("resource")[0]\n'})}),"\n",(0,i.jsxs)(n.p,{children:["如果一个页面唯一的资源就是主页面的 HTML 文档，然后 ",(0,i.jsx)(n.code,{children:'getEntriesByType("resource")'}),"\n返回一个空数组，这时候应用 ",(0,i.jsx)(n.code,{children:"element[0]"})," 会引起 JavaScript 异常。如果你找不到\n没有引用子资源的页面，你可以试试 ",(0,i.jsx)(n.a,{href:"https://fast.stevesouders.com/",target:"_blank",rel:"noopener noreferrer",children:"https://fast.stevesouders.com/"})]}),"\n",(0,i.jsxs)(n.h2,{id:"3-小心-secureconnectionstart-的问题",children:["3. 小心 ",(0,i.jsx)(n.code,{children:"secureConnectionStart"})," 的问题。",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-小心-secureconnectionstart-的问题",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://www.w3.org/TR/resource-timing/#dom-performanceresourcetiming-secureconnectionstart",target:"_blank",rel:"noopener noreferrer",children:(0,i.jsx)(n.code,{children:"secureConnectionStart"})}),"\n属性我们衡量 SSL 协商需要多长时间。这非常重要，我经常\n看到 500 毫秒以上的 SSL 协商时间，甚至更多。",(0,i.jsx)(n.code,{children:"secureConnectionStart"})," 有 3 种\n可能的值："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["如果该属性不可用，则必须设置为 ",(0,i.jsx)(n.code,{children:"undefined"}),"。"]}),"\n",(0,i.jsx)(n.li,{children:"如果不使用 HTTPS 的，则必须设置为 0."}),"\n",(0,i.jsx)(n.li,{children:"如果该属性可用，并且使用了 HTTPS，则必须设置为一个时间戳。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["关于 ",(0,i.jsx)(n.code,{children:"secureConnectionStart"}),"，有三件事情需要了解下："]}),"\n",(0,i.jsxs)(n.p,{children:["首先，在 Internet Explorer 中，",(0,i.jsx)(n.code,{children:"secureConnectionStart"})," 的值总是 ",(0,i.jsx)(n.code,{children:"undefined"}),"，\n因为它是不可用的（该值被埋在 [WinINet](",(0,i.jsx)(n.a,{href:"https://msdn.microsoft.com/en-us/library/windows/desktop/aa383630(v=vs.85%5C).aspx",target:"_blank",rel:"noopener noreferrer",children:"https://msdn.microsoft.com/en-us/library/windows/desktop/aa383630(v=vs.85\\).aspx"}),") 之下）。"]}),"\n",(0,i.jsxs)(n.p,{children:["其次，在 Chrome 中有个 BUG 会导致 ",(0,i.jsx)(n.code,{children:"secureConnectionStart"})," 被错误的设置为 0 的问题。\n如果获取一个资源时使用预先存在的 HTTPS 连接，则 ",(0,i.jsx)(n.code,{children:"secureConnectionStart"})," 将被设置\n为 0，而实际上它应该是一个时间戳。（详情请参考 ",(0,i.jsx)(n.a,{href:"https://code.google.com/p/chromium/issues/detail?id=404501",target:"_blank",rel:"noopener noreferrer",children:"bug 404501"})," ）\n为了避免这个问题，测量 SSL 协商时间时，一定要检查 ",(0,i.jsx)(n.code,{children:"secureConnectionStart"})," 既不是\n",(0,i.jsx)(n.code,{children:"undefined"})," 也不是 ",(0,i.jsx)(n.code,{children:"0"}),"："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'var r0 = performance.getEntriesByType("resource")[0];\nif ( r0.secureConnectionStart ) {\n    var ssl = r0.connectEnd - r0.secureConnectionStart;\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["第三，规范中关于 ",(0,i.jsx)(n.a,{href:"https://www.w3.org/TR/resource-timing/#dom-performanceresourcetiming-secureconnectionstart",target:"_blank",rel:"noopener noreferrer",children:"这一行"}),"\n有一些误导：“...如果当前页面的协议是 HTTPS，这个属性必须立即返回用户代理(user agent)开始握手过程的时间...”\n（我的重点）。有可能当前页面是 HTTP，但仍然包含我们需要测量 SSL 协商时间的 HTTPS 资源。\n规范应该改为：“...如果资源的协议是 HTTPS 协议，该属性必须立即返回用户代理开始握手过程的时间...”。\n幸运的是，浏览器是使用纠正后的行为，而已就是说， ",(0,i.jsx)(n.code,{children:"secureConnectionStart"})," 可用于\nHTTP 页面中的 HTTPS 资源。"]}),"\n",(0,i.jsxs)(n.h2,{id:"4-给跨域资源添加-timing-allow-origin-http-响应头",children:["4. 给跨域资源添加 ",(0,i.jsx)(n.code,{children:"Timing-Allow-Origin"})," HTTP 响应头",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-给跨域资源添加-timing-allow-origin-http-响应头",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["出于隐私保护的原因，在获得资源的 Resource Timing 详情时有",(0,i.jsx)(n.a,{href:"https://www.w3.org/TR/resource-timing/#cross-origin-resources",target:"_blank",rel:"noopener noreferrer",children:"跨域限制"}),"。\n默认情况下，与主页面不同域的资源，下列属性被设置为 0："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"redirectStart"}),"\n",(0,i.jsx)(n.li,{children:"redirectEnd"}),"\n",(0,i.jsx)(n.li,{children:"domainLookupStart"}),"\n",(0,i.jsx)(n.li,{children:"domainLookupEnd"}),"\n",(0,i.jsx)(n.li,{children:"connectStart"}),"\n",(0,i.jsx)(n.li,{children:"connectEnd"}),"\n",(0,i.jsx)(n.li,{children:"secureConnectionStart"}),"\n",(0,i.jsx)(n.li,{children:"requestStart"}),"\n",(0,i.jsx)(n.li,{children:"responseStart"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:['在某些情况下，仍然希望测量跨域资源的性能，例如，当网站使用不用域名的 CDN（例如\n"youtube.com" 使用 "s.ytimg.com"），以及某些第三方资源（例如 "ajax.googleapis.com"）。\n如果资源返回 ',(0,i.jsx)(n.a,{href:"https://www.w3.org/TR/resource-timing/#timing-allow-origin",target:"_blank",rel:"noopener noreferrer",children:"Timing-Allow-Origin"}),"\n响应头，跨域资源的 timing 详情将被授权访问。这个头信息指定了被允许访问 timing\n详情的（主页面）来源列表，多数情况下，会使用通配符(",(0,i.jsx)(n.code,{children:"*"}),") 允许所有来源访问。\n举个例子，",(0,i.jsx)(n.a,{href:"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js",target:"_blank",rel:"noopener noreferrer",children:"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"})," 返回\n的 Timing-Allow-Origin 响应头信息是："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Timing-Allow-Origin: *\n"})}),"\n",(0,i.jsxs)(n.p,{children:["当第三方添加这个响应头信息时，真是太棒了。它允许站长来统计在他们网页上使用的\n第三方资源的性能。感谢 ",(0,i.jsx)(n.a,{href:"https://googledevelopers.blogspot.com/2013/12/measuring-network-performance-with.html",target:"_blank",rel:"noopener noreferrer",children:"Ilya Grigorik"}),"\n报告了一些添加了这个响应头的第三方资讯，下面是一些指定了 ",(0,i.jsx)(n.code,{children:"Timing-Allow-Origin: *"}),"\n的资源例子："]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Google Hosted Libraries: ",(0,i.jsx)(n.a,{href:"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js",target:"_blank",rel:"noopener noreferrer",children:"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"})]}),"\n",(0,i.jsxs)(n.li,{children:["Google+ widgets: ",(0,i.jsx)(n.a,{href:"https://apis.google.com/js/plusone.js",target:"_blank",rel:"noopener noreferrer",children:"https://apis.google.com/js/plusone.js"})]}),"\n",(0,i.jsxs)(n.li,{children:["Google Fonts:  ",(0,i.jsx)(n.a,{href:"https://fonts.gstatic.com/s/opensans/v9/DXI%5Bsnip...%5DN3Vs.woff2",target:"_blank",rel:"noopener noreferrer",children:"https://fonts.gstatic.com/s/opensans/v9/DXI[snip...]N3Vs.woff2"})]}),"\n",(0,i.jsxs)(n.li,{children:["Facebook widgets: ",(0,i.jsx)(n.a,{href:"https://connect.facebook.net/en_US/all.js",target:"_blank",rel:"noopener noreferrer",children:"https://connect.facebook.net/en_US/all.js"})]}),"\n",(0,i.jsxs)(n.li,{children:["Disqus widgets: ",(0,i.jsx)(n.a,{href:"https://go.disqus.com/embed.js",target:"_blank",rel:"noopener noreferrer",children:"https://go.disqus.com/embed.js"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["当需要访问有限制的 timing 属性时，决定统计 Resource Timing 是非常重要的。\n可以通过检测（上面列出的，secureConnectionStart 除外）限制性属性是否为 0 的方式\n来避免限制性问题，我总是使用 ",(0,i.jsx)(n.code,{children:"requestStart"}),"。下面是用于在计算详细的性能指标之前，\n检测和计算限制性属性是否可用的代码片段："]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'// Resource Timing\nvar r0 = performance.getEntriesByType("resource")[0],\n    loadtime = r0.duration;\nif ( r0.requestStart ) {\n    var dns = r0.domainLookupEnd - r0.domainLookupStart,\n        tcp = r0.connectEnd - r0.connectStart,\n        ttfb = r0.responseStart - r0.startTime;\n}\nif ( r0.secureConnectionStart ) {\n    var ssl = r0.connectEnd - r0.secureConnectionStart;\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["做这些检测是非常重要的，否则，当访问这些受限属性时，你不会得到任何异常，除了\n这些虚假的数据。当属性受限访问时，它们的值被设置为 0，例如 ",(0,i.jsx)(n.code,{children:"domainLookupEnd - domainLookupStart"}),"\n翻译成 ",(0,i.jsx)(n.code,{children:"0 - 0"}),"，它返回一个似是而非的结果 ",(0,i.jsx)(n.code,{children:"0"}),"，而这可能并不是真实 DNS 查询时间。\n这将导致过多的指标为 ",(0,i.jsx)(n.code,{children:"0"})," 而让你过于乐观。"]}),"\n",(0,i.jsxs)(n.h2,{id:"5-理解-0-意味着什么",children:["5. 理解 0 意味着什么。",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#5-理解-0-意味着什么",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"在第 4 节当中提到，一些因为跨域导致的受限访问的 Resource Timing 属性会被设置为\n0。再强调一次，在访问属性详情之前，要检查属性状态是非常重要的。\n但是即使受限属性都是可访问的，度量计算的返回结果也有可能是 0，所以理解这意味着\n什么非常重要。"}),"\n",(0,i.jsxs)(n.p,{children:["例如，（假设没有访问限制）",(0,i.jsx)(n.code,{children:"domainLookupStart"})," 和 ",(0,i.jsx)(n.code,{children:"domainLookupEnd"})," 的值是两个\n时间戳，这两个值之差是该资源在 DNS 解析上耗时。通常情况下，一个页面中指定的域名\n只有一个非 0 的 DNS 解析耗时，因为浏览器会缓存 DNS 解析，所有后续的请求都使用\n这个缓存的 DNS 解析。而且由于跨页面的 DNS 解析缓存，一个页面所有的 DNS 解析\n计算结果可能都是 0。关键点：DNS 解析耗时为 0 意味着资源是从缓存中读取的。"]}),"\n",(0,i.jsxs)(n.p,{children:["同样，对于指定的主机名，如果重复利用已存在的 TCP 连接，那么建立 TCP 连接（",(0,i.jsx)(n.code,{children:"connectEnd - connectStart"}),"）\n的耗时也会是 0。每个主机有大约 6 个独立的 TCP 连接，这表明应该有 6 个非 0 的\nTCP 连接测量值，但是这个主机后续的请求将使用已存在的 TCP 连接，并且他们的\nTCP 连接耗时为 0。关键点：TCP 连接耗时为 0 意味着重复使用了已存在的 TCP 连接。"]}),"\n",(0,i.jsxs)(n.p,{children:["这同样适用于计算 SSL 协商（",(0,i.jsx)(n.code,{children:"connectEnd - secureConnectionStart"}),"）。这个可能\n有 6 个以上的资源，但是同一主机名的所有的后续请求可能都使用同一个已存在的 HTTPS\n连接，以至于它的 SSL 协商时间为 0。"]}),"\n",(0,i.jsx)(n.p,{children:"最后，如果属性持续的为 0，这可能意味资源是从缓存中读取的。"}),"\n",(0,i.jsxs)(n.h2,{id:"6-确定-304-是否被测量",children:["6. 确定 304 是否被测量。",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#6-确定-304-是否被测量",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["这是另一个 Chrome 稳定版（版本号 36）的 BUG，这个 BUG 在 37 版时被修复。\n这个问题已经被修复了，但是由于大多数用户还是使用 Chrome 稳定版，你当前的性能\n指标可能跟实际上的并不相同。这个 BUG 是：一个拥有 Timing-Allow-Origin 的跨域\n页面，200 响应状态并不会考虑 304 响应状态，因此，304 响应下所有的受限属性都\n将显示为 0，例如 ",(0,i.jsx)(n.a,{href:"https://stevesouders.com/tests/tao.php",target:"_blank",rel:"noopener noreferrer",children:"这个测试页面"}),"。"]}),"\n",(0,i.jsxs)(n.p,{children:["这是不应该发生的，因为从 200 响应的缓存中读取的 Timing-Allow-Origin 头信息\n应该应用到 304 响应中。在 Internet Explorer 浏览器中就是这样。（可以在 IE 10\n或者 11 中尝试 ",(0,i.jsx)(n.a,{href:"https://stevesouders.com/tests/tao.php",target:"_blank",rel:"noopener noreferrer",children:"这个页面"})," 来确认。）\n（感谢 ",(0,i.jsx)(n.a,{href:"https://twitter.com/ericlaw",target:"_blank",rel:"noopener noreferrer",children:"Eric Lawrence"})," 指出这一点。）"]}),"\n",(0,i.jsx)(n.p,{children:"这会影响你的 Chrome Resource Timing 结果如下："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"如果（如第 4 节所述）使用检查 0 值的方式来判断受限字段，则会跳过测量 304 响应，\n也就是说值测量了 200 状态响应，但是由于 200 状态响应比 304 要慢，所以 Resource\nTiming 测量总量会比实际的要大。"}),"\n",(0,i.jsx)(n.li,{children:"反之如果不检查受限字段为 0 的情况，会得到许多的 0 值记录，\n这实际上又比 304 响应要快，这样 Resource Timing 统计结果又会过于乐观。"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["没有简单的方式来避免这些偏见，但是好消息是这个 BUG 被修复了。另外还可以尝试做的\n事情是，304 响应头中发送 Timing-Allow-Origin 头，不幸的是，流行的 Apache Web\n服务器不支持在 304 响应头中发送这个头信息（查看 ",(0,i.jsx)(n.a,{href:"https://issues.apache.org/bugzilla/show_bug.cgi?id=51223",target:"_blank",rel:"noopener noreferrer",children:"BUG 51223"}),"）。\n缺乏进一步证件证明第 4 节提到那些第三方资源的 304 响应头中的 Timing-Allow-Origin\n可以被找到。如前所述，这些第三方资源在 200 响应头中返回 Timing-Allow-Origin 头，\n但是 304 响应头中不返回 Timing-Allow-Origin 头，这真是太好了。\n到 Chrome 37 成为稳定版之前，因为缺少了受限属性的细节，Resource Timing 测量结果\n可能偏高或偏低。幸运的是，时间会改变一切。"]}),"\n",(0,i.jsxs)(n.h2,{id:"7-看看-boomerang回旋镖",children:["7. 看看 Boomerang（回旋镖）.",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#7-看看-boomerang回旋镖",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["如果你准备写自己 Resource Timing 代码，建议你最好看看 ",(0,i.jsx)(n.a,{href:"https://www.lognormal.com/boomerang/doc/api/restiming.html",target:"_blank",rel:"noopener noreferrer",children:"Resource Timing 插件 Boomerang"}),"。\n（代码在 ",(0,i.jsx)(n.a,{href:"https://github.com/lognormal/boomerang/blob/master/plugins/restiming.js",target:"_blank",rel:"noopener noreferrer",children:"GitHub"})," 上。）\nBoomerang 是 Philip Tellis 维护的一个非常流行的开源 RUM 包。他起初在 Yahoo 工作\n的时候就开源了 Boomerang，而现在作为在 SOASTA 工作的商业版的一部分（mPulse），\n他仍然在持续的提供维护和增强。t它的代码很清晰、简洁和健壮，并解决了上面提到的许多问题。"]}),"\n",(0,i.jsx)(n.p,{children:"总之，Navigation Timing 和 Resource Timing 都是非常优秀的新规范，为站长了解他们\n的页面性能提供了很好的支持。Resource Timing 是这两个规范中更新的一个规范，因此\n还是会有一些问题待解决。这些小提示将帮助你充分的利用 Resource Timing 指标。\n我建议你现在就开始监控这些指标，以理解你的网站性能，为了最关心这个问题的真实用户。"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"更新：有一些第三方资源提供了 Timing-Allow-Origin 响应头，以允许站长测量这些\n第三方资源的性能："}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Boomerang: ",(0,i.jsx)(n.a,{href:"https://c.go-mpulse.net/boomerang/CEN%5Bsnip...%5DYQE",target:"_blank",rel:"noopener noreferrer",children:"https://c.go-mpulse.net/boomerang/CEN[snip...]YQE"})]}),"\n",(0,i.jsxs)(n.li,{children:["Typekit: ",(0,i.jsx)(n.a,{href:"https://use.typekit.net/previewkits/pk-v1.js",target:"_blank",rel:"noopener noreferrer",children:"https://use.typekit.net/previewkits/pk-v1.js"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)("p",{}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["更新：",(0,i.jsx)(n.code,{children:'getEntriesByType("resource")'})," 和 ",(0,i.jsx)(n.code,{children:"getEntries()"})," 不包含 iframe 页面的性能，\n如果 iframe 是同源的，可以在父页面通过 ",(0,i.jsx)(n.code,{children:"contentWindow.performance"})," 对象访问\n这些指标。"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"译者补充",children:["译者补充",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#译者补充",children:"#"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://www.stevesouders.com/blog/2014/08/21/resource-timing-practical-tips/",target:"_blank",rel:"noopener noreferrer",children:"Resource Timing practical tips"})," - 原文出处。"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)("footer",{class:"blog-post-footer",children:[(0,i.jsx)("div",{class:"blog-post-footer-meta meta-left",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Tags:"})," ",(0,i.jsx)("a",{href:"/blog/tags/HTML5",children:(0,i.jsx)("cite",{class:"tags",children:"HTML5"})}),", ",(0,i.jsx)("a",{href:"/blog/tags/%E7%BF%BB%E8%AF%91",children:(0,i.jsx)("cite",{class:"tags",children:"翻译"})})]})}),(0,i.jsx)("div",{class:"blog-post-footer-meta meta-right",children:(0,i.jsxs)(n.p,{children:["Published on ",(0,i.jsx)("cite",{class:"date",children:"2014-12-30"})]})})]}),"\n",(0,i.jsx)(o.DiscussionEmbed,{shortname:"hotoo",config:{url:"https://hotoo.co/blog/post/resource-timing-practical-tips.html",identifier:"/blog/post/resource-timing-practical-tips.html",title:"译：Resource Timing (资源计时) 使用技巧",language:"zh_CN"}})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(t,{...e})}):t(e)}let a=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["..%2Fnode_modules%2F.rspress%2Fruntime%2Ftemp-36.mdx"]={toc:[{text:'1. 使用 `getEntriesByType("resource")` 而不是 `getEntries()`',id:"1-使用-getentriesbytyperesource-而不是-getentries",depth:2},{text:"2. 使用 Navigation Timing 测量主页面的请求。",id:"2-使用-navigation-timing-测量主页面的请求",depth:2},{text:"3. 小心 `secureConnectionStart` 的问题。",id:"3-小心-secureconnectionstart-的问题",depth:2},{text:"4. 给跨域资源添加 `Timing-Allow-Origin` HTTP 响应头",id:"4-给跨域资源添加-timing-allow-origin-http-响应头",depth:2},{text:"5. 理解 0 意味着什么。",id:"5-理解-0-意味着什么",depth:2},{text:"6. 确定 304 是否被测量。",id:"6-确定-304-是否被测量",depth:2},{text:"7. 看看 Boomerang（回旋镖）.",id:"7-看看-boomerang回旋镖",depth:2},{text:"译者补充",id:"译者补充",depth:2}],title:"译：Resource Timing (资源计时) 使用技巧",headingTitle:"译：Resource Timing (资源计时) 使用技巧",frontmatter:{category:null,tags:"HTML5, 翻译",date:"2014-12-30T00:00:00.000Z",sidebar:!1,footer:!1}}}}]);