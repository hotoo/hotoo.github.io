"use strict";(self.webpackChunkhotoo_github_io=self.webpackChunkhotoo_github_io||[]).push([["458"],{16761:function(e,n,l){l.r(n),l.d(n,{default:()=>i});var r=l(74132),o=l(40453);function t(e){let n=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",ol:"ol",li:"li",h2:"h2",ul:"ul"},(0,o.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"非递归遍历-dom-结构",children:["非递归遍历 DOM 结构",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#非递归遍历-dom-结构",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["上次在Google+ 上说 ",(0,r.jsx)(n.a,{href:"https://plus.google.com/108314985261981078822/posts/ithY3w7tEWR",target:"_blank",rel:"noopener noreferrer",children:"实现了非递归遍历 DOM 结构"}),"，\n有朋友想让分享，我当然很高兴，但是很遗憾这本身没有什么值得分享的，大致如下，\n给大家随便看一下："]}),"\n",(0,r.jsx)(n.p,{children:"常见的递归方式遍历方式，下面是 Douglas Crockford 写的递归实现："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function walkTheDOM (node, func) {\n    func(node);\n    node = node.firstChild;\n    while (node) {\n        walkTheDOM(node, func);\n        node = node.nextSibling;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"然后有人自称写出了更快的遍历 DOM 方式。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'var elems = document.getElementsByTagName("*");\nfor(var i=0,l=elems.length; i<l; i++){\n    handler(elems[i]);\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["最初找到有详细对照的文章地址没有找到，这个是\n",(0,r.jsx)(n.a,{href:"http://geekswithblogs.net/mparsons/archive/2006/03/02/71175.aspx",target:"_blank",rel:"noopener noreferrer",children:"类似的一篇"}),"，\n而且也是非递归式的。"]}),"\n",(0,r.jsx)(n.p,{children:"确实是很快的，但只是快还是不够的，这个实现有很多弊端："}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"注释等元素未必会被遍历。"}),"\n",(0,r.jsx)(n.li,{children:"树形数据结构被整理成了平板结构，无法实现遍历过程的 in/out 处理。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"然后今天的主角隆重登场："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function walk(node, enter, leave){\n    var tmp, n=node;\n    label:\n    do{\n        enter(n);\n        if(tmp = firstNode(node)){ // firstChild(HTMLElement)\n            n = tmp;\n        }else if(tmp = nextNode(n)){ // nextSibling(HTMLElement)\n            n = tmp;\n        }else if(n.parentNode){\n            do{\n                n = n.parentNode;\n                leave(n);\n                if(n == node){break label;}\n                if(tmp = nextNode(n)){\n                    n = tmp;\n                    continue label;\n                }\n            }while(node);\n        }else{\n            break;\n        }\n    }while(n && n!=node);\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"上面只是一个精简版，实际过程中还需要考虑节点类型的问题，一般会过滤\n1:HTMLElement, 8:Comment, 9:Document Type, 10:DocType 之外的节点。"}),"\n",(0,r.jsx)(n.p,{children:"其实也不过如此嘛，飘过~~"}),"\n",(0,r.jsxs)(n.h2,{id:"see-also",children:["See Also",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#see-also",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"http://www.quirksmode.org/dom/intro.html",target:"_blank",rel:"noopener noreferrer",children:"W3C DOM -Introduction - ppk"})}),"\n"]})]})}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,o.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}let i=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["blog%2Fpost%2F2011%2Fnon-recursion-walk-the-dom.md"]={toc:[{text:"See Also",id:"see-also",depth:2}],title:"非递归遍历 DOM 结构",headingTitle:"非递归遍历 DOM 结构",frontmatter:[{template:"post.html"},{pubdate:"2011-07-10T00:00:00.000Z"},{tags:"JavaScript, 算法"}]}}}]);