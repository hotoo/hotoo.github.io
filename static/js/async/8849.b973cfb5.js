"use strict";(self.webpackChunkhotoo_github_io=self.webpackChunkhotoo_github_io||[]).push([["8849"],{60807:function(e,n,r){r.r(n),r.d(n,{default:()=>t});var s=r(74132),c=r(40453);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",blockquote:"blockquote",em:"em",code:"code",br:"br",pre:"pre",hr:"hr",strong:"strong",cite:"cite",footer:"footer",div:"div"},(0,c.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"正则表达式重复子模式前后倾的性能比较",children:["正则表达式重复子模式前、后倾的性能比较",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#正则表达式重复子模式前后倾的性能比较",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在准备内部的正则表达式 (Regular Expression)分享的过程中，\r\n注意到一个细节问题：重复的子模式，是应该前倾还是后倾，这两者在性能上有什么差异？"}),"\n",(0,s.jsx)(n.p,{children:"前倾和后倾是我胡诌的两个词，我的定义如下："}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"前倾"})," 就是前面的子表达式使用贪婪匹配或较大的量词，尽可能多的匹配内容，\r\n导致前面匹配的内容较多而使“天平”前倾。例如：",(0,s.jsx)(n.code,{children:"/(?:\\d{1,3}\\.){3}\\d{1,3}/"}),"。",(0,s.jsx)("br",{}),"\r\n",(0,s.jsx)(n.em,{children:"后倾"})," 则相反，后面的子表达式使用贪婪匹配或较大的量词。如：",(0,s.jsx)(n.code,{children:"/\\d{1,3}(?:\\.\\d{1,3}){3}/"}),"。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"\xa0"}),"\n",(0,s.jsx)(n.p,{children:"前倾和后倾在实际应用中很常见，如时间，主机名等，中间以某特殊字符（串?）分隔，\r\n被分隔部分的规则又相同的情况下，一般都是使用这两种实现方式之一。"}),"\n",(0,s.jsx)(n.p,{children:"上面定义中的两个例子只是简例，可以用来大致匹配 IPv4 地址，完整的 IPv4 地址正则式如下，\r\n它要求每段都在 0-255 之间：\r\n前倾："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"/^(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/\n"})}),"\n",(0,s.jsx)(n.p,{children:"后倾："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"/^(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(?:\\.(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}$/\n"})}),"\n",(0,s.jsxs)(n.p,{children:["我写了一个测试",(0,s.jsx)(n.a,{href:"https://hotoo.googlecode.com/svn/trunk/test/RegExp.front.end.html",target:"_blank",rel:"noopener noreferrer",children:"比较这两个正则性能"}),"\r\n的页面，在 IE7, FF3.6, Safari 4, Opera 10 下测试均为前倾的性能较高，Chrome 4 下则不相伯仲。"]}),"\n",(0,s.jsx)(n.p,{children:"p.s. 这种重复子模式，要有语法上的简写就好了，像 Perl 正则的递归引用（或类似运行时反向引用），\r\n维护起来就方便多了。"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Tags:"})," ",(0,s.jsx)("a",{href:"/blog/tags/RegExp",children:(0,s.jsx)("cite",{class:"tags",children:"RegExp"})})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Published on 2010-01-26"})}),"\n",(0,s.jsxs)("footer",{children:[(0,s.jsx)("div",{class:"meta-left",children:(0,s.jsxs)(n.p,{children:["Tags: ",(0,s.jsx)("a",{href:"/blog/tags/RegExp",children:(0,s.jsx)("cite",{class:"tags",children:"RegExp"})})]})}),(0,s.jsx)("div",{class:"meta-right",children:(0,s.jsxs)(n.p,{children:["Date: ",(0,s.jsx)("cite",{class:"date",children:"2010-01-26"})]})})]})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}let t=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["..%2Fnode_modules%2F.rspress%2Fruntime%2Ftemp-137.mdx"]={toc:[],title:"正则表达式重复子模式前、后倾的性能比较",headingTitle:"正则表达式重复子模式前、后倾的性能比较",frontmatter:{category:null,tags:"RegExp",date:"2010-01-26T00:00:00.000Z"}}}}]);