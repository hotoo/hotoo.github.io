"use strict";(self.webpackChunkhotoo_co=self.webpackChunkhotoo_co||[]).push([["8849"],{807:function(e,r,n){n.r(r),n.d(r,{default:()=>i});var s=n(4132),o=n(453),t=n(3030);function c(e){let r=Object.assign({h1:"h1",a:"a",p:"p",blockquote:"blockquote",em:"em",code:"code",br:"br",pre:"pre",footer:"footer",div:"div",strong:"strong",cite:"cite"},(0,o.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"正则表达式重复子模式前后倾的性能比较",children:["正则表达式重复子模式前、后倾的性能比较",(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#正则表达式重复子模式前后倾的性能比较",children:"#"})]}),"\n",(0,s.jsx)(r.p,{children:"在准备内部的正则表达式 (Regular Expression)分享的过程中，\r\n注意到一个细节问题：重复的子模式，是应该前倾还是后倾，这两者在性能上有什么差异？"}),"\n",(0,s.jsx)(r.p,{children:"前倾和后倾是我胡诌的两个词，我的定义如下："}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.em,{children:"前倾"})," 就是前面的子表达式使用贪婪匹配或较大的量词，尽可能多的匹配内容，\r\n导致前面匹配的内容较多而使“天平”前倾。例如：",(0,s.jsx)(r.code,{children:"/(?:\\d{1,3}\\.){3}\\d{1,3}/"}),"。",(0,s.jsx)("br",{}),"\r\n",(0,s.jsx)(r.em,{children:"后倾"})," 则相反，后面的子表达式使用贪婪匹配或较大的量词。如：",(0,s.jsx)(r.code,{children:"/\\d{1,3}(?:\\.\\d{1,3}){3}/"}),"。"]}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"\xa0"}),"\n",(0,s.jsx)(r.p,{children:"前倾和后倾在实际应用中很常见，如时间，主机名等，中间以某特殊字符（串?）分隔，\r\n被分隔部分的规则又相同的情况下，一般都是使用这两种实现方式之一。"}),"\n",(0,s.jsx)(r.p,{children:"上面定义中的两个例子只是简例，可以用来大致匹配 IPv4 地址，完整的 IPv4 地址正则式如下，\r\n它要求每段都在 0-255 之间：\r\n前倾："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"/^(?:(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/\n"})}),"\n",(0,s.jsx)(r.p,{children:"后倾："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"/^(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(?:\\.(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}$/\n"})}),"\n",(0,s.jsxs)(r.p,{children:["我写了一个测试",(0,s.jsx)(r.a,{href:"https://hotoo.googlecode.com/svn/trunk/test/RegExp.front.end.html",target:"_blank",rel:"noopener noreferrer",children:"比较这两个正则性能"}),"\r\n的页面，在 IE7, FF3.6, Safari 4, Opera 10 下测试均为前倾的性能较高，Chrome 4 下则不相伯仲。"]}),"\n",(0,s.jsx)(r.p,{children:"p.s. 这种重复子模式，要有语法上的简写就好了，像 Perl 正则的递归引用（或类似运行时反向引用），\r\n维护起来就方便多了。"}),"\n",(0,s.jsxs)("footer",{class:"blog-post-footer",children:[(0,s.jsx)("div",{class:"blog-post-footer-meta meta-left",children:(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Tags:"})," ",(0,s.jsx)("a",{href:"/blog/tags/RegExp",children:(0,s.jsx)("cite",{class:"tags",children:"RegExp"})})]})}),(0,s.jsx)("div",{class:"blog-post-footer-meta meta-right",children:(0,s.jsxs)(r.p,{children:["Published on ",(0,s.jsx)("cite",{class:"date",children:"2010-01-26"})]})})]}),"\n",(0,s.jsx)(t.DiscussionEmbed,{shortname:"hotoo",config:{url:"https://hotoo.co/blog/post/performance-for-regex-repeat-sub-pattern.html",identifier:"/blog/post/performance-for-regex-repeat-sub-pattern.html",title:"正则表达式重复子模式前、后倾的性能比较",language:"zh_CN"}})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,o.ah)(),e.components);return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}let i=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["..%2Fnode_modules%2F.rspress%2Fruntime%2Ftemp-137.mdx"]={toc:[],title:"正则表达式重复子模式前、后倾的性能比较",headingTitle:"正则表达式重复子模式前、后倾的性能比较",frontmatter:{category:null,tags:"RegExp",date:"2010-01-26T00:00:00.000Z",sidebar:!1,footer:!1}}}}]);